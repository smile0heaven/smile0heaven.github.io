<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Animation 动画深度分析View Animation 视图动画，也叫Tween（补间）动画可以在一个视图容器内执行一系列简单变换（位置、大小、旋转、透明度）。譬如，如果你有一个TextView对象，您可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。  Alpha(透明度) 属性：用于控制动画的透明度 Rotate（旋转）属性 ：可以对视图进行旋转">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2017/06/19/动画/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Animation 动画深度分析View Animation 视图动画，也叫Tween（补间）动画可以在一个视图容器内执行一系列简单变换（位置、大小、旋转、透明度）。譬如，如果你有一个TextView对象，您可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。  Alpha(透明度) 属性：用于控制动画的透明度 Rotate（旋转）属性 ：可以对视图进行旋转">
<meta property="og:updated_time" content="2017-06-19T09:28:03.211Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="Animation 动画深度分析View Animation 视图动画，也叫Tween（补间）动画可以在一个视图容器内执行一系列简单变换（位置、大小、旋转、透明度）。譬如，如果你有一个TextView对象，您可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。  Alpha(透明度) 属性：用于控制动画的透明度 Rotate（旋转）属性 ：可以对视图进行旋转">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-动画" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/19/动画/" class="article-date">
  <time datetime="2017-06-19T07:31:20.478Z" itemprop="datePublished">2017-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Animation-动画深度分析"><a href="#Animation-动画深度分析" class="headerlink" title="Animation 动画深度分析"></a>Animation 动画深度分析</h1><h2 id="View-Animation"><a href="#View-Animation" class="headerlink" title="View Animation"></a>View Animation</h2><p> 视图动画，也叫Tween（补间）动画可以在一个视图容器内执行一系列简单变换（位置、大小、旋转、透明度）。譬如，如果你有一个TextView对象，您可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。</p>
<ol>
<li>Alpha(透明度) 属性：用于控制动画的透明度</li>
<li>Rotate（旋转）属性 ：可以对视图进行旋转</li>
<li>Scale（缩放）属性：对视图进行缩放</li>
<li>Translate属性：可以对视图进行变换</li>
<li>AnimationSet继承自Animation，是上面四种的组合容器管理类，没有自己特有的属性，他的属性继承自Animation，当我们对set标签使用Animation的属性时会对该标签下的所有子控件都产生影响。</li>
<li>Interpolator（插值器）属性：类似于动画以一个什么样的速率去执行动画</li>
</ol>
<p>`</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   
android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;  
android:shareInterpolator=[&quot;true&quot; | &quot;false&quot;] &gt;
&lt;alpha
    android:fromAlpha=&quot;float&quot;
    android:toAlpha=&quot;float&quot; /&gt;
&lt;scale
    android:fromXScale=&quot;float&quot;
    android:toXScale=&quot;float&quot;
    android:fromYScale=&quot;float&quot;
    android:toYScale=&quot;float&quot;
    android:pivotX=&quot;float&quot;
    android:pivotY=&quot;float&quot; /&gt;
&lt;translate
    android:fromXDelta=&quot;float&quot;
    android:toXDelta=&quot;float&quot;
    android:fromYDelta=&quot;float&quot;
    android:toYDelta=&quot;float&quot; /&gt;
&lt;rotate
    android:fromDegrees=&quot;float&quot;
    android:toDegrees=&quot;float&quot;
    android:pivotX=&quot;float&quot;
    android:pivotY=&quot;float&quot; /&gt;
&lt;set&gt;
    ...
&lt;/set&gt;
</code></pre><p>`</p>
<table>
<thead>
<tr>
<th>View类的常用动画操作方法</th>
<th>解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td>startAnimation(Animation animation)</td>
<td>对当前View开始设置的Animation动画</td>
</tr>
<tr>
<td>clearAnimation()</td>
<td>取消当View在执行的Animation动画</td>
</tr>
</tbody>
</table>
<p><strong>补间动画执行之后并未改变View的真实布局属性值。我们对一个Button进行操作，将他从原来的位置移动到另一位置，但是实际响应button事件的位置，还是原来的位置。</strong></p>
<p>##Drawable Animation<br> Drawable动画其实就是Frame动画（帧动画），它允许你实现像播放幻灯片一样的效果，这种动画的实质其实是Drawable，所以这种动画的XML定义方式文件一般放在res/drawable/目录下。加载效果的实现</p>
<ol>
<li><animation-list> 必须是根节点，包含一个或者多个item元素，包含属性如下：<ul>
<li>android:oneshot true代表只执行一次，false循环执行。</li>
</ul>
</animation-list></li>
<li>item 类似一帧的动画资源，animation-list的子项，包含属性如下：<ul>
<li>android:drawable 一个frame的Drawable资源。</li>
<li>android:duration 一个frame显示多长时间。</li>
</ul>
</li>
</ol>
<p><strong>AnimationDrawable的start()方法不能在Activity的onCreate方法中调运，因为AnimationDrawable还未完全附着到window上，所以最好的调运时机是onWindowFocusChanged()方法中。</strong></p>
<p>##Property Animation<br> 属性动画只对Android 3.0（API 11）以上版本的Android系统才有效，这种动画可以设置给任何Object，包括那些还没有渲染到屏幕上的对象。这种动画是可扩展的，可以让你自定义任何类型和属性的动画。<strong>实现原理就是修改控件的属性值实现的动画，改变的是对象的真实属性</strong><br>基本属性如下：</p>
<ul>
<li>Duration：动画的持续时间；</li>
<li>TimeInterpolation：定义动画变化速率的接口，所有插值器都必须实现此接口，如线性、非线性插值器；</li>
<li>TypeEvaluator：用于定义属性值计算方式的接口，有int、float、color类型，根据属性的起始、结束值和插值一起计算出当前时间的属性值；</li>
<li>Animation sets：动画集合，即可以同时对一个对象应用多个动画，这些动画可以同时播放也可以对不同动画设置不同的延迟；</li>
<li>Frame refreash delay：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响；</li>
<li>Repeat Country and behavoir：重复次数与方式，如播放3次、5次、无限循环，可以让此动画一直重复，或播放完时向反向播放；  </li>
</ul>
<p>###1.set属性解释：</p>
<table>
<thead>
<tr>
<th>xml属性</th>
<th>解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td> android:ordering</td>
<td>控制子动画启动方式是先后有序的还是同时进行。sequentially:动画按照先后顺序；together(默认):动画同时启动 </td>
</tr>
</tbody>
</table>
<p>###2.objectAnimator属性解释：</p>
<table>
<thead>
<tr>
<th>xml属性</th>
<th>解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td>android:propertyName</td>
<td>String类型，必须要设置的节点属性，代表要执行动画的属性（通过名字引用），辟如你可以指定了一个View的”alpha” 或者 “backgroundColor” ，这个objectAnimator元素没有对外说明target属性，所以你不能在XML中设置执行这个动画，必须通过调用 loadAnimator()方法加载你的XML动画资源，然后调用setTarget()应用到具备这个属性的目标对象上（譬如TextView）。</td>
</tr>
<tr>
<td>android:valueTo</td>
<td>float、int或者color类型，必须要设置的节点属性，表明动画结束的点；如果是颜色的话，由6位十六进制的数字表示。</td>
</tr>
<tr>
<td>android:valueFrom</td>
<td>相对应valueTo，动画的起始点，如果没有指定，系统会通过属性的get方法获取，颜色也是6位十六进制的数字表示。</td>
</tr>
<tr>
<td>android:duration</td>
<td>动画的时长，int类型，以毫秒为单位，默认为300毫秒。</td>
</tr>
<tr>
<td>android:startOffset</td>
<td>动画延迟的时间，从调用start方法后开始计算，int型，毫秒为单位。</td>
</tr>
<tr>
<td>android:repeatCount</td>
<td>一个动画的重复次数，int型，”-1“表示无限循环，”1“表示动画在第一次执行完成后重复执行一次，也就是两次，默认为0，不重复执行。</td>
</tr>
<tr>
<td>android:repeatMode</td>
<td>重复模式：int型，当一个动画执行完的时候应该如何处理。该值必须是正数或者是-1，“reverse”会使得按照动画向相反的方向执行，可实现类似钟摆效果。“repeat”会使得动画每次都从头开始循环。</td>
</tr>
<tr>
<td>android:valueType</td>
<td>关键参数，如果该value是一个颜色，那么就不需要指定，因为动画框架会自动的处理颜色值。有intType和floatType（默认）两种：分别说明动画值为int和float型。</td>
</tr>
</tbody>
</table>
<p>###3.XML属性动画使用方法：</p>
<pre><code>AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,
R.animtor.property_animator);
set.setTarget(myObject);
set.start();
</code></pre><p>###4.ValueAnimator实现动画<br>属性动画中的时间驱动，管理着动画时间的开始、结束属性值，相应时间属性值计算方法等。包含所有计算动画值的核心函数以及每一个动画时间节点上的信息、一个动画是否重复、是否监听更新事件等，并且还可以设置自定义的计算类型。<br><strong>ValueAnimator只是动画计算管理驱动，设置了作用目标，但没有设置属性，需要通过updateListener里设置属性才会生效。</strong></p>
<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(0, mContentHeight);  //定义动画
animator.setTarget(view);   //设置作用目标
animator.setDuration(5000).start();
animator.addUpdateListener(new AnimatorUpdateListener() {
@Override
public void onAnimationUpdate(ValueAnimator animation){
    float value = (float) animation.getAnimatedValue();
    view.setXXX(value);  //必须通过这里设置属性值才有效
    view.mXXX = value;  //不需要setXXX属性方法
}
});
</code></pre><p>###5.ObjectAnimator实现动画<br>继承自ValueAnimator，允许你指定要进行动画的对象以及该对象 的一个属性。不需要和ValueAnimator那样自己写动画更新的逻辑，但是ObjectAnimator有一定的限制，比如它需要目标对象的属性提供指定 的处理方法（譬如提供getXXX，setXXX方法）<br>ObjectAnimator类提供了ofInt、ofFloat、ofObject这个三个常用的方法，这些方法都是设置动画作用的元素、属性、开始、结束等任意属性值。当属性值（上面方法的参数）只设置一个时就把通过getXXX反射获取的值作为起点，设置的值作为终点；如果设置两个（参数），那么一个是开始、另一个是结束。<br><strong>ObjectAnimator的动画原理是不停的调用setXXX方法更新属性值，所有使用ObjectAnimator更新属性时的前提是Object必须声明有getXXX和setXXX方法。</strong><br>我们通常使用ObjectAnimator设置View已知的属性来生成动画，而一般View已知属性变化时都会主动触发重绘图操作，所以动画会自 动实现；但是也有特殊情况，譬如作用Object不是View，或者作用的属性没有触发重绘，或者我们在重绘时需要做自己的操作，那都可以通过如下方法手 动设置：</p>
<pre><code>ObjectAnimator mObjectAnimator= ObjectAnimator.ofInt(view, &quot;customerDefineAnyThingName&quot;, 0,  1).setDuration(2000);
mObjectAnimator.addUpdateListener(new AnimatorUpdateListener()
    {
        @Override
        public void onAnimationUpdate(ValueAnimator animation)
        {
            //int value = animation.getAnimatedValue();  可以获取当前属性值
            //view.postInvalidate();  可以主动刷新
            //view.setXXX(value);
            //view.setXXX(value);
            //......可以批量修改属性
        }
    });
</code></pre><p>ValueAnimator和ObjectAnimator没啥区别，实际上正是由于ValueAnimator不直接操作属性值，所以要操作对象的属性可以不需要setXXX与getXXX方法，你完全可以通过当前动画的计算去修改任何属性。</p>
<p>###6.AnimatorSet的使用<br>动画集合，提供把多个动画组合成一个组合的机制，并可设置动画的时序关系，如同时播放、顺序播放或延迟播放    </p>
<pre><code>ObjectAnimator a1 = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1.0f, 0f);  
ObjectAnimator a2 = ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0f, viewWidth);  
......
AnimatorSet animSet = new AnimatorSet();  
animSet.setDuration(5000);  
animSet.setInterpolator(new LinearInterpolator());   
//animSet.playTogether(a1, a2, ...); //两个动画同时执行  
animSet.play(a1).after(a2); //先后执行
......//其他组合方式
animSet.start();  
</code></pre><p>###7.Evaluators<br> Evaluators就是属性动画系统如何去计算一个属性值。它们通过Animator提供的动画的起始和结束值去计算一个动画的属性值。</p>
<p>IntEvaluator：整数属性值。</p>
<p>FloatEvaluator：浮点数属性值。</p>
<p>ArgbEvaluator：十六进制color属性值。</p>
<p>TypeEvaluator：用户自定义属性值接口，譬如对象属性值类型不是int、float、color类型，你必须实现这个接口去定义自己的数据类型。</p>
<p>如下类型float[]：</p>
<pre><code>ValueAnimator valueAnimator = new ValueAnimator();
valueAnimator.setDuration(5000);
valueAnimator.setObjectValues(new float[2]); //设置属性值类型
valueAnimator.setInterpolator(new LinearInterpolator());
valueAnimator.setEvaluator(new TypeEvaluator&lt;float[]&gt;()
{
@Override
public float[] evaluate(float fraction, float[] startValue,
                        float[] endValue)
{
    //实现自定义规则计算的float[]类型的属性值
    float[] temp = new float[2];
    temp[0] = fraction * 2;
    temp[1] = (float)Math.random() * 10 * fraction;
    return temp;
}
});

valueAnimator.start();
valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener()
{
@Override
public void onAnimationUpdate(ValueAnimator animation)
{
    float[] xyPos = (float[]) animation.getAnimatedValue();
    view.setHeight(xyPos[0]);   //通过属性值设置View属性动画
    view.setWidth(xyPos[1]);    //通过属性值设置View属性动画
}
});
</code></pre><p>###8.Interpolators插值器</p>
<ul>
<li><p>AccelerateDecelerateInterolator：先加速后减速。</p>
</li>
<li><p>AccelerateInterpolator：加速。</p>
</li>
<li><p>DecelerateInterpolator：减速。</p>
</li>
<li><p>AnticipateInterpolator：先向相反方向改变一段再加速播放。</p>
</li>
<li><p>AnticipateOvershootInterpolator：先向相反方向改变，再加速播放，会超出目标值然后缓慢移动至目标值，类似于弹簧回弹。</p>
</li>
<li><p>BounceInterpolator：快到目标值时值会跳跃。</p>
</li>
<li><p>CycleIinterpolator：动画循环一定次数，值的改变为一正弦函数：Math.sin(2 <em> mCycles </em> Math.PI * input)。</p>
</li>
<li><p>LinearInterpolator：线性均匀改变。</p>
</li>
<li><p>OvershottInterpolator：最后超出目标值然后缓慢改变到目标值。</p>
</li>
<li><p>TimeInterpolator：一个允许自定义Interpolator的接口，以上都实现了该接口。  </p>
<p> 自定义插值器：   </p>
<p>  //开始很慢然后不断加速的插值器<br>  public class AccelerateInterpolator implements Interpolator {<br>  private final float mFactor;<br>  private final double mDoubleFactor;</p>
<p>  public AccelerateInterpolator() {</p>
<pre><code>mFactor = 1.0f;
mDoubleFactor = 2.0;
</code></pre><p>  }<br>  //input  0到1.0。表示动画当前点的值，0表示开头，1表示结尾。<br>  //return  插值。值可以大于1超出目标值，也可以小于0突破低值。<br>  @Override<br>  public float getInterpolation(float input) {</p>
<pre><code>//实现核心代码块
if (mFactor == 1.0f) {
    return input * input;
} else {
    return (float)Math.pow(input, mDoubleFactor);
}
</code></pre><p>  }<br>  }</p>
</li>
</ul>
<p>###9.LayoutAnimator容器布局动画<br>对ViewGroup中View添加时的动画功能，我们可以用LayoutTransition对 ViewGroup中的View进行动画设置显示。LayoutTransition的动画效果都是设置给ViewGroup，然后当被<strong>设置动画的 ViewGroup中添加删除View时体现出来</strong>。该类用于当前布局容器中有View添加、删除、隐藏、显示等时候定义布局容器自身的动画和View的动 画，也就是说当在一个LinerLayout中隐藏一个View的时候，我们可以自定义 整个由于LinerLayout隐藏View而改变的动画，同时还可以自定义被隐藏的View自己消失时候的动画等。</p>
<p> LayoutTransition类中主要有五种容器转换动画类型，具体如下：</p>
<ul>
<li><p>LayoutTransition.APPEARING：当View出现或者添加的时候View出现的动画。</p>
</li>
<li><p>LayoutTransition.CHANGE_APPEARING：当添加View导致布局容器改变的时候整个布局容器的动画。</p>
</li>
<li><p>LayoutTransition.DISAPPEARING：当View消失或者隐藏的时候View消失的动画。</p>
</li>
<li><p>LayoutTransition.CHANGE_DISAPPEARING：当删除或者隐藏View导致布局容器改变的时候整个布局容器的动画。</p>
</li>
<li><p>LayoutTransition.CHANGE：当不是由于View出现或消失造成对其他View位置造成改变的时候整个布局容器的动画。</p>
</li>
</ul>
<p>XML方式使用系统提供的默认LayoutTransition动画：</p>
<p>我们可以通过如下方式使用系统提供的默认ViewGroup的LayoutTransition动画：</p>
<p>android:animateLayoutChanges=”true”</p>
<p>在ViewGroup添加如上xml属性默认是没有任何动画效果的，因为前面说了，该动画针对于ViewGroup内部东西发生改变时才有效，所以当我们设置如上属性然后调运ViewGroup的addView、removeView方法时就能看见系统默认的动画效果了。</p>
<p>还有一种就是通过如下方式设置：</p>
<p>android:layoutAnimation=”@anim/customer_anim”</p>
<p>在使用LayoutTransition时，你可以自定义这几种事件类型的动画，也可以使用默认的动画，总之最终都是通过 setLayoutTransition(LayoutTransition lt)方法把这些动画以一个LayoutTransition对象设置给一个ViewGroup。</p>
<p>譬如实现如上Xml方式的默认系统LayoutTransition动画如下：</p>
<pre><code>mTransitioner = new LayoutTransition();
mViewGroup.setLayoutTransition(mTransitioner);
</code></pre><p>自定义这几类事件的动画，分别实现他们，可以像下面这么处理：</p>
<pre><code>mTransitioner = new LayoutTransition();
......
ObjectAnimator anim = ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, 0, 1);
......//设置更多动画
mTransition.setAnimator(LayoutTransition.APPEARING, anim);
.....//设置更多类型的动画                
mViewGroup.setLayoutTransition(mTransitioner);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/19/动画/" data-id="cj43xw7kx000244l1bgkc9v0s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/19/README/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2017/06/19/自定义View/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/19/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/06/19/动画/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/06/19/自定义View/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/06/19/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>