<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Smile&#39;Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-28T03:26:22.819Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS学习手册</title>
    <link href="http://yoursite.com/2019/10/15/JS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2019/10/15/JS学习手册/</id>
    <published>2019-10-14T16:00:00.000Z</published>
    <updated>2020-02-28T03:26:22.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="var-和-let"><a href="#var-和-let" class="headerlink" title="var 和 let"></a>var 和 let</h2><h5 id="var"><a href="#var" class="headerlink" title="var"></a>var</h5><p>1.声明变量时，如果使用了var，则其作用域限制在其声明位置的上下文中，但未使用var声明时，在执行赋值时，将会隐式的创建为全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function x() &#123;</div><div class="line">  y = 1;   // 会被创建为全局变量</div><div class="line">  var z = 2;//作用域在函数X中</div><div class="line">&#125;</div><div class="line">x();</div><div class="line"></div><div class="line">console.log(y); // 打印 &quot;1&quot;</div><div class="line">console.log(z); // 抛出 ReferenceError: z 未在 x 外部声明</div><div class="line">```   </div><div class="line">2. 声明变量在任何代码执行前创建，(即使console可能写在变量声明前，但是由于变量提升，声明语句其实会在最前执行)而非声明变量只有在执行赋值操作的时候才会被创建。</div></pre></td></tr></table></figure></p>
<p>console.log(a);                // 抛出ReferenceError。</p>
<p>console.log(b);<br>var b;//变量提升，打印”undefined”或””（不同浏览器实现不同）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3. 声明变量是它所在上下文环境的不可配置属性，非声明变量是可配置的（如非声明变量可以被删除）。</div></pre></td></tr></table></figure></p>
<p>var a = 1;<br>b = 2;</p>
<p>delete this.a; // 在严格模式（strict mode）下抛出TypeError，其他情况下执行失败并无任何提示。<br>delete this.b;</p>
<p>console.log(a, b); // 抛出ReferenceError。<br>// ‘b’属性已经被删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">变量提升</div></pre></td></tr></table></figure></p>
<p>‘use strict’;</p>
<p>function foo() {<br>    var x = ‘Hello, ‘ + y;<br>    console.log(x);<br>    var y = ‘Bob’;<br>}</p>
<p>foo()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">虽然是strict模式，但语句var x = &apos;Hello, &apos; + y;并不报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。    </div><div class="line">对于上述foo()函数，JavaScript引擎看到的代码相当于：</div></pre></td></tr></table></figure></p>
<p>function foo() {<br>    var y; // 提升变量y的申明，此时y为undefined<br>    var x = ‘Hello, ‘ + y;<br>    console.log(x);<br>    y = ‘Bob’;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">##### let  </div><div class="line">1.let声明的变量只在其声明的块或子块中可用(包括只有一个大括号)，而var声明的变量的作用域是整个封闭函数</div></pre></td></tr></table></figure></p>
<p>function varTest() {<br>  var x = 1;<br>  {<br>    var x = 2;  // 同样的变量!<br>    console.log(x);  // 2<br>  }<br>  console.log(x);  // 2<br>}</p>
<p>function letTest() {<br>  let x = 1;<br>  {<br>    let x = 2;  // 不同的变量<br>    console.log(x);  // 2<br>  }<br>  console.log(x);  // 1<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.位于函数或代码顶部的var声明会给全局对象新增属性, 而let不会。</div></pre></td></tr></table></figure></p>
<p>var x = ‘global’;<br>let y = ‘global’;<br>console.log(this.x); // “global”<br>console.log(this.y); // undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">## js的方法赋值     </div><div class="line">下面的赋值方式 会导致getImg在赋值时被调用一次，</div></pre></td></tr></table></figure></p>
<p> newImage.onclick = getImg(e)</p>
<p>function getImg(e) {<br>    const src = e.target.getAttribute(‘src’)<br>    displayedImage.setAttribute(‘src’, src);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">所以应该改为</div></pre></td></tr></table></figure></p>
<p> newImage.onclick = function (e) {<br>        getImg(e)<br>    }</p>
<p>function getImg(e) {<br>    const src = e.target.getAttribute(‘src’)<br>    displayedImage.setAttribute(‘src’, src);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">## 闭包 </div><div class="line">### 含义</div><div class="line">有权访问另一个函数作用域中的变量的函数。闭包真正的含义是，如果一个函数访问了此函数的父级及父级以上的作用域变量，就可以称这个函数是一个闭包。</div><div class="line">### 作用  </div><div class="line">1、可以在函数的外部访问到函数内部的局部变量。  </div><div class="line">2、让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</div></pre></td></tr></table></figure></p>
<p>//循环里面包含闭包函数<br>function box(){<br>    var arr = [];<br>    for(var i=0;i<5;i++){ arr[i]="function(){" return="" i;="" 由于这个闭包的关系，他是循环完毕之后才返回，最终结果是4++是5="" }="" 这个匿名函数里面根本没有i这个变量，所以匿名函数会从父级函数中去找i，="" 当找到这个i的时候，for循环已经循环完毕了，所以最终会返回5="" 另外循环体内声明了一个匿名函数，而这个匿名函数并没有得到执行，所以arr数组每个元素都是一个匿名函数="" function(){return="" i}="" arr;="" alert(box());="" 执行5次匿名函数本身="" alert(box()[1]);　　　　　　　　　　　　　　　　　　　="" 执行第2个匿名函数本身="" alert(box().length);="" 最终返回的是一个数组，数组的长度为5="" alert(box()[0]());="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">上面这段代码就形成了一个闭包：</div><div class="line">闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见的方式，就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量。</div><div class="line">在for循环里面的匿名函数执行 return i 语句的时候，由于匿名函数里面没有i这个变量，所以这个i他要从父级函数中寻找i，而父级函数中的i在for循环中，当找到这个i的时候，是for循环完毕的i，也就是5，所以这个box得到的是一个数组[5,5,5,5,5]。  </div><div class="line">解决方法一    </div><div class="line">匿名函数自我执行的写法是，在函数体外面加一对圆括号，形成一个表达式，在圆括号后面再加一个圆括号，里面可传入参数。</div></pre></td></tr></table></5;i++){></p>
<p>(function(){<br>    alert(‘lee’);                        //匿名函数自我执行(匿名函数)()<br>})();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果将一个匿名函数自我执行的时候赋值给一个变量，那么这个匿名函数中的圆括号的可以去掉的，看下面代码，</div></pre></td></tr></table></figure></p>
<p>var tip = function(){                                //这样把匿名函数自我执行的时候赋值给一个变量，那么圆括号是可以去掉的<br>    alert(‘lee’);<br>}();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">所以 最终解决方法是</div></pre></td></tr></table></figure></p>
<p>function box(){<br>    var arr = [];<br>    for(var i=0;i<5;i++){ arr[i]="function(num){" 自我执行，并传参(将匿名函数形成一个表达式)(传递一个参数)="" return="" num;="" 这里的num写什么都可以="" }(i);="" 这时候这个括号里面的i和上面arr[i]的值是一样的都是取自for循环里面的i="" }="" arr;="" alert(box());="" alert(box()[1]);="" alert(box().length);="" alert(box()[0]);="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">通过给匿名函数传参，而传递的这个参数i是每次执行for循环里面的i，每次传递的参数i的值都不一样，匿名函数里面的num接收传递的参数i，所以box()最终输出结果为[0,1,2,3,4]  </div><div class="line"></div><div class="line">解决方法二  </div><div class="line">这种方案的原理就是在匿名函数1里面再写入一个匿名函数2，这个匿名函数2需要的num值会在他的父级函数匿名函数1里面去寻找，而匿名函数1里面的num值就是传入的这个参数i，和上面例子中的i是一样的</div></pre></td></tr></table></5;i++){></p>
<p>function box(){<br>    var arr = [];<br>    for(var i=0;i&lt;5;i++){<br>        arr[i] = (function(num){<br>        //num在这里                                    //原理和上面一种方法一样的，所以可以实现闭包<br>            return function(){                        //在这个闭包里面再写一个匿名函数<br>                return num;<br>            };<br>        })(i)<br>    }<br>    return arr;<br>}<br>//alert(box());<br>//alert(box()[1]);<br>//alert(box().length);<br>var b = box();<br>alert(b<a href="">0</a>);<br>alert(box()<a href="">0</a>);<br>```</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;var-和-let&quot;&gt;&lt;a href=&quot;#var-和-let&quot; class=&quot;headerlink&quot; title=&quot;var 和 let&quot;&gt;&lt;/a&gt;var 和 let&lt;/h2&gt;&lt;h5 id=&quot;var&quot;&gt;&lt;a href=&quot;#var&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="Java Script" scheme="http://yoursite.com/categories/Java-Script/"/>
    
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="http://yoursite.com/2019/10/12/%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/10/12/注解/</id>
    <published>2019-10-11T16:00:00.000Z</published>
    <updated>2020-02-28T03:46:49.297Z</updated>
    
    <content type="html"><![CDATA[<p>定义注解需要使用@inteface关键字  </p>
<pre><code class="java"><span class="meta">@Target</span>(ElementType.METHOD)
<span class="meta">@Retention</span>(RetentionPolicy.SOURCE)
<span class="keyword">public</span> <span class="meta">@interface</span> Override {
}
</code></pre>
<p>在override上有两个注解，被称为元注解，（元注解：用来定义注解的注解），为了定义注解什么的使用范围，使用时间等<br>元注解共有四种@Retention, @Target, @Inherited, @Documented<br>@Retention  保留的范围，默认值为CLASS. </p>
<ol>
<li>source 只在源码中使用</li>
<li>class只在源码和字节码中使用</li>
<li>runtime 在源码，字节码以及运行时使用  </li>
</ol>
<p>@target 用于修饰哪些程序元素使用  如 TYPE（类）, METHOD{方法}, CONSTRUCTOR（构造方法）, FIELD,PARAMETER等，未标注则表示可修饰所有<br>@Inherited 是否能被继承  默认为false<br>@Documented 是否会被保存在javadoc文档中<br>@retention 是定义的保留策略，决定我们用何种方式解析，source级别只是用来标记，不在实际编译中起作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义注解需要使用@inteface关键字  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(ElementType.METHOD)
&lt;span class=&quot;meta&quot;&gt;@Retention&lt;/s
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Android/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>当静态变量为null引发的血案</title>
    <link href="http://yoursite.com/2019/08/15/%E5%BD%93%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%BAnull%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/"/>
    <id>http://yoursite.com/2019/08/15/当静态变量为null引发的血案/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2020-02-28T03:25:34.879Z</updated>
    
    <content type="html"><![CDATA[<p>我们会在APP中使用一些静态变量或者在application中声明对象来保存数据，但是这可能导致app闪退</p>
<p>实际 来说，静态变量和application中的数据是不会被系统回收的，但是当我们将APP退到后台后，系统可能因为内存不足回收我们的APP，这时，activity栈数据还保留着，我们将APP切换到前台时，就会出现异常，假设我们之前开启的APP页面的顺序是A-B-C,这时候 回到前台时，首先出现的就是C页面，但是由于我们静态变量的初始化可能放在其他页面，或者application中中保存了一个user，我们在A页面对user进行赋值了，但是由于APP重新新建了一个进程，application里中的数据都清空了，所以在C页面获取静态变量的值和user中的数据是null,这样就会发生空指针异常。  </p>
<blockquote>
<p>既然静态变量会被销毁，那我们获取C页面时的intent会不会也是null呢？  </p>
<p>答案是不会的，因为系统维护的task和activity栈帮我们处理了Intent（以及其中的数据）的保存和恢复。简单来说，所有“曾用于启动activity的intent”和“还没有被销毁的activity”都会被系统维护在task栈中，并且当进程被回收时，安卓系统会自动帮我们把这些信息保存起来</p>
</blockquote>
<ol>
<li>内存重启：表现是 App从后台进入前台的过程中， 因为内存数据之前已经被回收，系统会从最后一个显示的 Activity 开始一步步恢复 Activity 和 Activity 状态。</li>
<li>Activity 状态 - 初始状态 ：初始状态为 Activity 加载了一个 layout 布局，还没有获取任何的 id 、操作 view 、开始异步加载数据。</li>
<li>Activity 状态 - 数据渲染状态：初始状态以后开始加载数据和渲染改变一些界面的状态，会以一个方法作为入口，正常启动会直接 onCreate 初始状态后进入 数据渲染状态，但我的做法是内存重启 的时候会在 Activity 的 onActivityResult 才进入数据渲染状态。那么具体怎么做到呢？</li>
</ol>
<p>解决方案<br>假定：恢复的 Activity 为 RestoreActivity，引导页 Activity 为 AppStartActivity</p>
<ol>
<li>在所有 Activity 的基类中有判断，若 onCreate 发现是内存重启的情况下，RestoreActivity<br>的 startActivityForResult 启动一个引导界面AppStartActivity，同时结束 onCreate 不进入 数据渲染状态，直到启动页面结束返回，这个恢复的 Activity 被系统调用了 onActivityResult 通知我们结果，然后根据接收到返回的对应 result code 进入 数据渲染状态 。</li>
<li>第二点很重要的是，在这个引导界面进行一些 App 的全局数据单例的恢复（例如：已登录的用户单例信息），当然根据需求可以适当预访问或预加载一些比较急需的 App 全局数据，加速返回后的恢复页 Activity 的界面展现，因为引导页的时间一般都会有最低3秒或有个最低秒数阈值，所以理论上可以合理预加载一点数据利用一下，然后到达一定时间就要返回，引导界面的关键就是恢复关键数据和预加载数据<br>为什么会这么设计呢？有心人注意去测试看看 微信 的启动，真正的内存重启的时候，会让你看到 小人 + 地球 的引导 Activity，再返回真正的对应恢复 Activity，用户体验上也是内存重启就会出现一个相对较友好的引导界面做了一个长期的用户认知培养，而不是一个 正在加载或容易 crash 的界面。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们会在APP中使用一些静态变量或者在application中声明对象来保存数据，但是这可能导致app闪退&lt;/p&gt;
&lt;p&gt;实际 来说，静态变量和application中的数据是不会被系统回收的，但是当我们将APP退到后台后，系统可能因为内存不足回收我们的APP，这时，act
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>内存泄漏</title>
    <link href="http://yoursite.com/2019/07/30/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2019/07/30/内存泄漏/</id>
    <published>2019-07-29T16:00:00.000Z</published>
    <updated>2020-02-28T03:29:34.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>主要由于内存未能及时释放回收造成，</p>
<p>而内存什么时候需要被回收 ，我们就需要先了解一下回收机制,了解这些之前 我们需要补充一些基础的知识</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><ol>
<li>寄存器：我们在程序中无法控制,又叫程序计数器。JVM支持多个线程同时运行，当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）。如果线程正在执行的是一个Java方法（非native），那么PC寄存器的值将总是指向下一条将被执行的指令，如果方法是 native的，程序计数器寄存器的值不会被定义。 JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。</li>
<li>栈：存放基础数据类型以及对象的引用，每个线程拥有一个栈</li>
<li>堆：存放对象，使用new产生的数据.注意创建出来的对象只包含属于各自的成员变量，并不包括成员方法。因为同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是他们共享该类的方法，并不是每创建一个对象就把成员方法复制一次 </li>
<li>方法区：当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享</li>
</ol>
<ul>
<li>静态域：使用static定义的静态成员</li>
<li>常量池：存放常量</li>
<li>类信息：包括类以及方法和域名的信息</li>
</ul>
<ol>
<li>非RAM(随机存取存储器)存储：硬盘等永久存储空间  </li>
</ol>
<p>一：在方法中声明的变量，即使变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因。<br>在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。<br>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中<br>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。<br>二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。<br>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量<br>（1）当声明的是基本类型的变量其变量名及其值放在堆内存中的<br>（2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中.  </p>
<table>
<thead>
<tr>
<th>xxx</th>
<th>局部变量</th>
<th>成员变量 </th>
</tr>
</thead>
<tbody>
<tr>
<td>基本数据类型</td>
<td>变量名和值都在方法栈中</td>
<td>变量名和值都在堆内存中</td>
</tr>
<tr>
<td>引用数据类型</td>
<td>变量名在方法栈中，变量指向的对象在堆中</td>
<td>变量名和变量指向的对象都在堆中</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">    Heart myHeart = new Heart();</div><div class="line"></div><div class="line">&#125;</div><div class="line">class Heart&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <img src="https://note.youdao.com/yws/api/personal/file/7AFC09A305BE4E2BB8D0DB35BB8319C4?method=download&amp;shareKey=52d9e44ec8b85b7f0ad88234649c04b8" alt="image"></p>
<p>方法中的局部变量在栈中是不数据共享的，而栈中一般数据共享，所以i=1,j=1的时候i=j;而堆中的对象一般不数据共享<br>java虚拟机栈是线程私有的，生命周期跟线程相同，每个方法调用的时候都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用的过程，就代表了一个栈帧在虚拟机栈中入栈到出栈的过程，当进入一个方法时，这个方法在栈中需要分配多大的内存都是完全确定的，方法运行时不会改变局部变量表的大小——《深入理解java虚拟机第二版》<br><img src="https://note.youdao.com/yws/api/personal/file/A2DC978CE3154F489DC37233C6E85178?method=download&amp;shareKey=1c1edb9bb6b4767d928deaba832fb0bc" alt="image"></p>
<a id="more"></a>
<h3 id="对象以及对象引用（栈和堆）"><a href="#对象以及对象引用（栈和堆）" class="headerlink" title="对象以及对象引用（栈和堆）"></a>对象以及对象引用（栈和堆）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Demo demo=<span class="keyword">new</span> Demo();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>左边的 Demo demo代表创建一个Demo类引用变量 ，存储在栈空间中</li>
<li>new Demo()代表我们在堆空间中创建了一个demo对象  </li>
<li>=操作符使对象引用指向Demo对象</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/C7686C66AA7741DB9C1F9EB81E4BB70A?method=download&amp;shareKey=0908dc67c50fcd65b9488ffcdd87e1ae" alt="image"></p>
<p>引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能被使用，但仍 然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。<br>Java的堆优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态 分配内存，存取速度较慢。<br>栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量数据（int, short, long, byte, float, double, boolean, char）和对象句柄(引用)。</p>
<p>　　</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）的常量值(final)还包含一些以文本形式出现的符号引用，比如： </p>
<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4>　　对于字符串，其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份，基本类型的包装类和字符串相似，除了两种浮点数类型的包装类没有实现（但他们维护的常量仅仅是【-128至127】这个范围内的常量，如果常量值超过这个范围，就会从堆中创建对象，不再从常量池中取。）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">String s1 = <span class="string">"china"</span>;</div><div class="line">String s2 = <span class="string">"china"</span>;</div><div class="line">String s3 = <span class="string">"china"</span>;</div><div class="line"></div><div class="line">String ss1 = <span class="keyword">new</span> String(<span class="string">"china"</span>);</div><div class="line">String ss2 = <span class="keyword">new</span> String(<span class="string">"china"</span>);</div><div class="line">String ss3 = <span class="keyword">new</span> String(<span class="string">"china"</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/E1D88392AA994A5FBFE7349EA6EEA7AB?method=download&amp;shareKey=397b3222906159137130a77ed5ad67e1" alt="image"></p>
<p>对于通过new产生一个字符串（假设为“china”）时，会先去常量池中查找是否已经有了“china”对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此”china”对象的拷贝对象。</p>
<h4 id="基础类型的变量和常量"><a href="#基础类型的变量和常量" class="headerlink" title="基础类型的变量和常量"></a>基础类型的变量和常量</h4><p>对于基础类型的变量和常量，变量和引用存储在栈中，常量存储在常量池中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i1 = <span class="number">9</span>;</div><div class="line">      <span class="keyword">int</span> i2 = <span class="number">9</span>;</div><div class="line">      <span class="keyword">int</span> i3 = <span class="number">9</span>;</div><div class="line"></div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> INT1 = <span class="number">9</span>;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> INT2 = <span class="number">9</span>;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> INT3 = <span class="number">9</span>;</div></pre></td></tr></table></figure></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/8A99B51B41E04A308F6084CD989D5AA7?method=download&amp;shareKey=7150d5c4201d0f491a004248c733228e" alt="image"></p>
<p>　编译器先处理int i1 = 9；首先它会在栈中创建一个变量为i1的引用，然后查找栈中是否有9这个值，如果没找到，就将9存放进来，然后将i1指向9。接着处理int i2 = 9；在创建完i2的引用变量后，因为在栈中已经有9这个值，便将i2直接指向9。这样，就出现了i1与i2同时均指向9的情况。最后i3也指向这个9。  
　
　</p>
<h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><p>对于成员变量和局部变量：成员变量就是方法外部，类的内部定义的变量；局部变量就是方法或语句块内部定义的变量。局部变量必须初始化。 形式参数是局部变量，局部变量的数据存在于栈内存中。栈内存中的局部变量随着方法的消失而消失。 成员变量存储在堆中的对象里面，由垃圾回收器负责回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">　　<span class="class"><span class="keyword">class</span> <span class="title">BirthDate</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BirthDate</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        day = d;</div><div class="line">        month = m;</div><div class="line">        year = y;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 省略get,set方法………</span></div><div class="line">    &#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> date = <span class="number">9</span>;</div><div class="line">        Test test = <span class="keyword">new</span> Test();</div><div class="line">        test.change(date);</div><div class="line">        BirthDate d1 = <span class="keyword">new</span> BirthDate(<span class="number">7</span>, <span class="number">7</span>, <span class="number">1970</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        i = <span class="number">1234</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/5EC2D27D9E894DAFBA2A7544B28AF11A?method=download&amp;shareKey=f5fb13ce87e3fcf79cf0c5edc99728ad" alt="image"></p>
<h2 id="当class字节码文件被jvm虚拟机加载到内存中依次经过"><a href="#当class字节码文件被jvm虚拟机加载到内存中依次经过" class="headerlink" title="当class字节码文件被jvm虚拟机加载到内存中依次经过"></a>当class字节码文件被jvm虚拟机加载到内存中依次经过</h2><p>连接<br>　　验证：对字节码进行验证<br>　　准备：给静态变量分配内存并赋予变量类型各自的默认值（注：基本类型为0或false，对象为null，static final修饰的常量直接赋予相应的值）<br>　　解析：类中符号引用转换成直接引用<br>初始化：为类的静态变量/静态语句块初始化相应的值<br>而类的初始化契机是：类在被第一次主动使用的情况下，主动使用包括以下6中情况：</p>
<ul>
<li>使用new关键字实例化对象时。</li>
<li>调用某个类的静态方法时。</li>
<li>读取或设置类的静态字段时（被final修饰、已在编译期把结果放入常量池的除外）。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用。</li>
<li>初始化某个类的子类时。</li>
<li>虚拟机启动时被标明为启动类（包含main方法的类）。<br>静态成员变量的初始化发生在类的 初始化阶段，而要实例化一个对象就必须先去加载、连接、以及初始化该类，才能去使用该类去实例化对象，而非静态成员变量的初始化发生在对象的实例化过程中。</li>
</ul>
<h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><ol>
<li><p>强引用（Strong Reference）：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
</li>
<li><p>软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。SoftReference类来实现软引用。</p>
</li>
<li><p>弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference类来实现弱引用。</p>
</li>
<li><p>虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。PhantomReference类来实现虚引用。</p>
</li>
</ol>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类和非静态内部类一样，都是在被调用时才会被加载  </p>
<p>静态内部类的加载不需要依附外部类，在使用时才加载。而加载非静态内部类的过程中也会加载外部类。</p>
<h2 id="判断对象是否需要被回收"><a href="#判断对象是否需要被回收" class="headerlink" title="判断对象是否需要被回收"></a>判断对象是否需要被回收</h2><p>采用根搜索算法<br>首先我们需要了解GC root的概念</p>
<h3 id="GC-root"><a href="#GC-root" class="headerlink" title="GC root"></a>GC root</h3><ol>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表）<br>我们知道，每个方法执行的时候，jvm都会创建一个相应的栈帧(栈帧中包括操作数栈、局部变量表、运行时常量池的引用)，栈帧中包含这在方法内部使用的所有对象的引用(当然还有其他的基本类型数据)，当方法执行完后，该栈帧会从虚拟机栈中弹出，这样一来，临时创建的对象的引用也就不存在了，或者说没有任何gc roots指向这些临时对象，这些对象在下一次GC时便会被回收掉</li>
<li>方法区中的常量引用的对象；</li>
<li>方法区中的类静态属性引用的对象；</li>
<li>本地方法栈中JNI（Native方法）的引用对象。<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3></li>
<li>通过“GC Roots”的对象作为起始点，寻找对应的引用节点。</li>
<li>找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。</li>
<li>重复（2）。</li>
<li><p>搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。</p>
<h3 id="关于标记阶段有几个关键点是值得注意的："><a href="#关于标记阶段有几个关键点是值得注意的：" class="headerlink" title="关于标记阶段有几个关键点是值得注意的："></a>关于标记阶段有几个关键点是值得注意的：</h3></li>
<li><p>开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的</p>
</li>
<li>暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。</li>
<li>在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：  <ul>
<li>如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行   finalize（）方法（可看作析构函数，类似于OC中的dealloc，Swift中的deinit）。当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。  </li>
<li>如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。</li>
</ul>
</li>
</ol>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>原因：持有对象的强引用，且没有及时释放，进而造成内存单元一直被占用，浪费空间，甚至可能造成内存溢出！</p>
<h3 id="Android中的内存泄漏"><a href="#Android中的内存泄漏" class="headerlink" title="Android中的内存泄漏"></a>Android中的内存泄漏</h3><ul>
<li>全局进程(process-global)的static变量。这个无视应用的状态，持有Activity的强引用的怪物。</li>
<li>活在Activity生命周期之外的线程。没有清空对Activity的强引用。<h4 id="Static-Activities"><a href="#Static-Activities" class="headerlink" title="Static Activities"></a>Static Activities</h4>在类中定义了静态Activity变量，把当前运行的Activity实例赋值于这个静态变量。<br>如果这个静态变量在Activity生命周期结束后没有清空，就导致内存泄漏。因为static变量是贯穿这个应用的生命周期的，所以被泄漏的Activity就会一直存在于应用的进程中，不会被垃圾回收器回收。<h4 id="单例模式引起的内存泄漏"><a href="#单例模式引起的内存泄漏" class="headerlink" title="单例模式引起的内存泄漏"></a>单例模式引起的内存泄漏</h4>由于单例的一般为static类，生命周期和整个应用的生命周期一致，如果该单例中持有页面中的数据，会导致该页面无法被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;  </div><div class="line">    <span class="keyword">private</span> Context context;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.context = context;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;  </div><div class="line">            instance = <span class="keyword">new</span> AppManager(context);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要：</p>
<p>1、传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长 ;</p>
<p>2、传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长(Activity间接继承于Context)，所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。</p>
<h4 id="Static-Views"><a href="#Static-Views" class="headerlink" title="Static Views"></a>Static Views</h4><p>如果一个View初始化耗费大量资源，而且在一个Activity生命周期内保持不变，那可以把它变成static，加载到视图树上(View Hierachy)，，当Activity被销毁时，应当释放资源。把static view置null即可，但是还是不建议用这个static view的方法</p>
<h4 id="Inner-Classes"><a href="#Inner-Classes" class="headerlink" title="Inner Classes"></a>Inner Classes</h4><p>非静态内部类持有外部类的隐式引用将会导致内存泄漏<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestResource mResource = <span class="keyword">null</span>;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">        setContentView(R.layout.activity_main);  </div><div class="line">        <span class="keyword">if</span>(mResource == <span class="keyword">null</span>)&#123;  </div><div class="line">            mResource = <span class="keyword">new</span> TestResource();  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">//...  </span></div><div class="line">    &#125;  </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;  </div><div class="line">        <span class="comment">//...  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Activity中有个内部类，这样做可以提高可读性和封装性。该内部类创建了一个静态的对象，将会持有外部类即Activity的引用，将导致Activity的内存资源不能正常回收。正确的做法为：将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请使用ApplicationContext ，或者在页面销毁的时候置空</p>
<h3 id="Anonymous-Classes"><a href="#Anonymous-Classes" class="headerlink" title="Anonymous Classes"></a>Anonymous Classes</h3><p>匿名内部类如果持有了外部的Activity，就会导致Activity销毁的时候不被回收<br>正如使用内部类一样，只要不跨越生命周期，内部类是完全没问题的。但是，这些类是用于产生后台线程的，这些Java线程是全局的，而且持有创建者的引用（即匿名类的引用），而匿名类又持有外部类的引用。线程是可能长时间运行的，所以一直持有Activity的引用导致当销毁时无法回收。例如handler，runnable<br>所以我们需要使用静态内部类，不持有外部类的引用，打破了链式引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NimbleHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handleMessage(message);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NimbleRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> NimbleHandler().postDelayed(<span class="keyword">new</span> NimbleRunnable(), Long.MAX_VALUE &gt;&gt; <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是，如果你坚持使用匿名类，创建一个静态匿名内部类，然后对个静态匿名内部持有的对象使用弱引用，这样在回收时也可以回收静态匿名内部持有的对象，这样虽然避免了Activity泄漏，不过比如handler的Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息，只要在生命周期结束时中断线程就可以。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);  </div><div class="line">    <span class="keyword">private</span> TextView mTextView ;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;  </div><div class="line">        <span class="keyword">private</span> WeakReference&lt;Context&gt; reference;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">            reference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);  </div><div class="line">        &#125;  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;  </div><div class="line">            MainActivity activity = (MainActivity) reference.get();  </div><div class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>)&#123;  </div><div class="line">                activity.mTextView.setText(<span class="string">""</span>);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">        setContentView(R.layout.activity_main);  </div><div class="line">        mTextView = (TextView)findViewById(R.id.textview);  </div><div class="line">        loadData();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">//...request  </span></div><div class="line">        Message message = Message.obtain();  </div><div class="line">        mHandler.sendMessage(message);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDestroy();  </div><div class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="资源未关闭造成的内存泄漏"><a href="#资源未关闭造成的内存泄漏" class="headerlink" title="资源未关闭造成的内存泄漏"></a>资源未关闭造成的内存泄漏</h4><p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;主要由于内存未能及时释放回收造成，&lt;/p&gt;
&lt;p&gt;而内存什么时候需要被回收 ，我们就需要先了解一下回收机制,了解这些之前 我们需要补充一些基础的知识&lt;/p&gt;
&lt;h2 id=&quot;内存分配&quot;&gt;&lt;a href=&quot;#内存分配&quot; class=&quot;headerlink&quot; title=&quot;内存分配&quot;&gt;&lt;/a&gt;内存分配&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;寄存器：我们在程序中无法控制,又叫程序计数器。JVM支持多个线程同时运行，当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）。如果线程正在执行的是一个Java方法（非native），那么PC寄存器的值将总是指向下一条将被执行的指令，如果方法是 native的，程序计数器寄存器的值不会被定义。 JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。&lt;/li&gt;
&lt;li&gt;栈：存放基础数据类型以及对象的引用，每个线程拥有一个栈&lt;/li&gt;
&lt;li&gt;堆：存放对象，使用new产生的数据.注意创建出来的对象只包含属于各自的成员变量，并不包括成员方法。因为同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是他们共享该类的方法，并不是每创建一个对象就把成员方法复制一次 &lt;/li&gt;
&lt;li&gt;方法区：当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;静态域：使用static定义的静态成员&lt;/li&gt;
&lt;li&gt;常量池：存放常量&lt;/li&gt;
&lt;li&gt;类信息：包括类以及方法和域名的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;非RAM(随机存取存储器)存储：硬盘等永久存储空间  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一：在方法中声明的变量，即使变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因。&lt;br&gt;在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。&lt;br&gt;（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中&lt;br&gt;（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。&lt;br&gt;二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。&lt;br&gt;同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量&lt;br&gt;（1）当声明的是基本类型的变量其变量名及其值放在堆内存中的&lt;br&gt;（2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中.  &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;xxx&lt;/th&gt;
&lt;th&gt;局部变量&lt;/th&gt;
&lt;th&gt;成员变量 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基本数据类型&lt;/td&gt;
&lt;td&gt;变量名和值都在方法栈中&lt;/td&gt;
&lt;td&gt;变量名和值都在堆内存中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;引用数据类型&lt;/td&gt;
&lt;td&gt;变量名在方法栈中，变量指向的对象在堆中&lt;/td&gt;
&lt;td&gt;变量名和变量指向的对象都在堆中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;class Person&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Heart myHeart = new Heart();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;class Heart&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  &lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/7AFC09A305BE4E2BB8D0DB35BB8319C4?method=download&amp;amp;shareKey=52d9e44ec8b85b7f0ad88234649c04b8&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法中的局部变量在栈中是不数据共享的，而栈中一般数据共享，所以i=1,j=1的时候i=j;而堆中的对象一般不数据共享&lt;br&gt;java虚拟机栈是线程私有的，生命周期跟线程相同，每个方法调用的时候都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用的过程，就代表了一个栈帧在虚拟机栈中入栈到出栈的过程，当进入一个方法时，这个方法在栈中需要分配多大的内存都是完全确定的，方法运行时不会改变局部变量表的大小——《深入理解java虚拟机第二版》&lt;br&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/A2DC978CE3154F489DC37233C6E85178?method=download&amp;amp;shareKey=1c1edb9bb6b4767d928deaba832fb0bc&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeakCanary源码分析</title>
    <link href="http://yoursite.com/2019/06/20/LeakCanary%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/06/20/LeakCanary源码分析/</id>
    <published>2019-06-19T16:00:00.000Z</published>
    <updated>2020-02-28T03:24:49.573Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>首先判断当前线程是不是主线程，如果是分析LeakCanary的线程的话，就不应该初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (LeakCanary.isInAnalyzerProcess(this)) &#123;//1</div><div class="line">            // This process is dedicated to LeakCanary for heap analysis.</div><div class="line">            // You should not init your app in this process.</div><div class="line">            return;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>2.执行install方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LeakCanary.install(this);</div></pre></td></tr></table></figure></p>
<p>我们来分析一下该方法中的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Creates a &#123;@link RefWatcher&#125; that works out of the box, and starts watching activity</div><div class="line"> * references (on ICS+).</div><div class="line"> */</div><div class="line">public static @NonNull RefWatcher install(@NonNull Application application) &#123;</div><div class="line">//DisplayLeakService这个用于最终展示分析泄露的服务</div><div class="line">//listenerServiceClass这个会生成一个HeapAnalyzerService 该服务用于分析内存泄露这个后面的分析中可以看出来</div><div class="line">  return refWatcher(application).listenerServiceClass(DisplayLeakService.class)</div><div class="line">      .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</div><div class="line">      .buildAndInstall();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法主要生成了一个RefWatcher对象，还有一个DisplayLeakService服务。该服务主要是用于分析HeapDump，写入一个记录文件，并弹出一个Notification，我们看一下buildAndInstall方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">  * Creates a &#123;@link RefWatcher&#125; instance and makes it available through &#123;@link</div><div class="line">  * LeakCanary#installedRefWatcher()&#125;.</div><div class="line">  *</div><div class="line">  * Also starts watching activity references if &#123;@link #watchActivities(boolean)&#125; was set to true.</div><div class="line">  *</div><div class="line">  * @throws UnsupportedOperationException if called more than once per Android process.</div><div class="line">  */</div><div class="line"> public @NonNull RefWatcher buildAndInstall() &#123;</div><div class="line"> //判断buildAndInstall是否已经执行过</div><div class="line">   if (LeakCanaryInternals.installedRefWatcher != null) &#123;</div><div class="line">     throw new UnsupportedOperationException(&quot;buildAndInstall() should only be called once.&quot;);</div><div class="line">   &#125;</div><div class="line">   //生成一个RefWatcher对象</div><div class="line">   RefWatcher refWatcher = build();</div><div class="line">   if (refWatcher != DISABLED) &#123;</div><div class="line">   //是否展示内存泄露的页面，这个默认是不展示的</div><div class="line">     if (enableDisplayLeakActivity) &#123;</div><div class="line">       LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);</div><div class="line">     &#125;</div><div class="line">     //是否监听activity</div><div class="line">     if (watchActivities) &#123;</div><div class="line">     我们主要来观察一下activity的方法</div><div class="line">       ActivityRefWatcher.install(context, refWatcher);</div><div class="line">     &#125;</div><div class="line">           //是否监听Fragment</div><div class="line">     if (watchFragments) &#123;</div><div class="line">       FragmentRefWatcher.Helper.install(context, refWatcher);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   LeakCanaryInternals.installedRefWatcher = refWatcher;</div><div class="line">   return refWatcher;</div><div class="line"> &#125;</div><div class="line"> ``` </div><div class="line"> </div><div class="line">   ActivityRefWatcher.install(context, refWatcher);就是实际监听的方法   </div><div class="line">#### watch</div></pre></td></tr></table></figure></p>
<p>  public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {<br>    Application application = (Application) context.getApplicationContext();<br>    //生成了一个ActivityRefWatcher对象<br>    ActivityRefWatcher对象 activityRefWatcher = new ActivityRefWatcher(application, refWatcher);<br>//调用application的registerActivityLifecycleCallbacks方法，可以监听每个activity页面的生命周期<br>    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);<br>  }</p>
<p>//该callback方法就是在每个页面销毁的时候调用了watch方法来监听内存泄露<br> private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =<br>      new ActivityLifecycleCallbacksAdapter() {<br>        @Override public void onActivityDestroyed(Activity activity) {<br>          refWatcher.watch(activity);<br>        }<br>      };</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>Watches the provided references and checks if it can be GCed. This method is non blocking,</li>
<li>the check is done on the {@link WatchExecutor} this {@link RefWatcher} has been constructed</li>
<li>with.<br>*</li>
<li><p>@param referenceName An logical identifier for the watched object.<br>*/<br>public void watch(Object watchedReference, String referenceName) {<br>if (this == DISABLED) {<br> return;<br>}<br>//监听activity时,watchedReference是一个activity<br>checkNotNull(watchedReference, “watchedReference”);<br>checkNotNull(referenceName, “referenceName”);<br>final long watchStartNanoTime = System.nanoTime();<br>String key = UUID.randomUUID().toString();<br>retainedKeys.add(key);<br>final KeyedWeakReference reference =<br>   new KeyedWeakReference(watchedReference, key, referenceName, queue);</p>
<p>ensureGoneAsync(watchStartNanoTime, reference);<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">拿到的 activity 引用，构造 KeyedWeakReference 对象，其实它继承自 WeakReference ，它是一个弱引用。构建弱引用的同时，在构造函数中添加 ReferenceQueue，当 activity 被回收时，KeyedWeakReference 对象会被添加到ReferenceQueue当中。如果出现内存泄漏，则 ReferenceQueue 找不到对应的 KeyedWeakReference 对象，那么就可以判断发生内存泄漏了。每一个KeyedWeakReferenced都有一个key，这样可以标志每一个独一无二的个KeyedWeakReference</div><div class="line">生成之后就是进行 检测回收</div><div class="line">#### ensureGoneAsync</div></pre></td></tr></table></figure>
<p>//可以看出该方法是在一个异步线程中执行的<br> private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {<br>    watchExecutor.execute(new Retryable() {<br>      @Override public Retryable.Result run() {<br>        return ensureGone(reference, watchStartNanoTime);<br>      }<br>    });<br>  }</p>
<p>  @SuppressWarnings(“ReferenceEquality”) // Explicitly checking for named null.<br>  Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {<br>    long gcStartNanoTime = System.nanoTime();<br>    //调用watch方法花的时间<br>    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</p>
<pre><code>// 移除不可达引用
removeWeaklyReachableReferences();
</code></pre><p>//检查是否有断点，导致产生错误的泄露判断<br>    if (debuggerControl.isDebuggerAttached()) {<br>      // The debugger can create false leaks.<br>      return RETRY;<br>    }<br>    //判断当前引用是不是不存在了，不存在则不继续执行<br>    if (gone(reference)) {<br>      return DONE;<br>    }<br>    //手动触发GC操作，gcTrigger中封装了gc操作的代码<br>    gcTrigger.runGc();</p>
<pre><code>//再次 移除不可达引用
removeWeaklyReachableReferences();
//如果两次判定都没有被回收，则开始分析这个引用，最终生成HeapDump信息
if (!gone(reference)) {
  long startDumpHeap = System.nanoTime();
  //记录gc以及清除所花费的时间
  long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
</code></pre><p>//生成一个文件，来保存内存分析信息<br>      File heapDumpFile = heapDumper.dumpHeap();<br>      if (heapDumpFile == RETRY_LATER) {<br>        // Could not dump the heap.<br>        return RETRY;<br>      }<br>      //生成分析文件的时间<br>      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</p>
<pre><code>HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)
    .referenceName(reference.name)
    .watchDurationMs(watchDurationMs)
    .gcDurationMs(gcDurationMs)
    .heapDumpDurationMs(heapDumpDurationMs)
    .build();
</code></pre><p>//解析这个分析,这个listener是创建RefWatcher初始化并传入的ServiceHeapDumpListener<br>      heapdumpListener.analyze(heapDump);<br>    }<br>    return DONE;<br>  }</p>
<p>  //该方法将已经回收的引用移除<br>  private void removeWeaklyReachableReferences() {<br>    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly<br>    // reachable. This is before finalization or garbage collection has actually happened.<br>    KeyedWeakReference ref;<br>    while ((ref = (KeyedWeakReference) queue.poll()) != null) {<br>      retainedKeys.remove(ref.key);<br>    }<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 弱引用与ReferenceQueue联合使用，如果弱引用关联的对象被回收，则会把这个弱引用加入到ReferenceQueue中；通过这个原理，可以看出removeWeaklyReachableReferences()执行后，会对应删除KeyedWeakReference的数据。如果这个引用继续存在，那么就说明没有被回收。</div><div class="line">2. 为了确保最大保险的判定是否被回收，一共执行了两次回收判定，包括一次手动GC后的回收判定。两次都没有被回收，很大程度上说明了这个对象的内存被泄漏了，但并不能100%保证；因此LeakCanary是存在极小程度的误差的。</div><div class="line"> heapdumpListener.analyze(heapDump)分析生成的heapDump文件主要使用了HeapAnalyzerService的runAnalysis方法</div></pre></td></tr></table></figure></p>
<p>public final class ServiceHeapDumpListener implements HeapDump.Listener {</p>
<p>  @Override public void analyze(@NonNull HeapDump heapDump) {<br>    checkNotNull(heapDump, “heapDump”);<br>    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);<br>  }<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">在HeapAnalyzerService服务中</div></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>This service runs in a separate process to avoid slowing down the app process or making it run</li>
<li><p>out of memory.<br>*/<br>public final class HeapAnalyzerService extends ForegroundService<br> implements AnalyzerProgressListener {</p>
<p>private static final String LISTENER_CLASS_EXTRA = “listener_class_extra”;<br>private static final String HEAPDUMP_EXTRA = “heapdump_extra”;</p>
</li>
</ul>
<p>//新建一个HeapAnalyzerService前台服务<br>  public static void runAnalysis(Context context, HeapDump heapDump,<br>      Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) {<br>    setEnabledBlocking(context, HeapAnalyzerService.class, true);<br>    setEnabledBlocking(context, listenerServiceClass, true);<br>    Intent intent = new Intent(context, HeapAnalyzerService.class);<br>    intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());<br>    intent.putExtra(HEAPDUMP_EXTRA, heapDump);<br>    ContextCompat.startForegroundService(context, intent);<br>  }</p>
<p>  public HeapAnalyzerService() {<br>    super(HeapAnalyzerService.class.getSimpleName(), R.string.leak_canary_notification_analysing);<br>  }</p>
<p>//主要实现方法<br>  @Override protected void onHandleIntentInForeground(@Nullable Intent intent) {<br>    if (intent == null) {<br>      CanaryLog.d(“HeapAnalyzerService received a null intent, ignoring.”);<br>      return;<br>    }<br>    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);<br>    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);</p>
<pre><code>HeapAnalyzer heapAnalyzer =
    new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses);
</code></pre><p>//调用AnalysisResult的checkForLeak方法来分析文件<br>    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,<br>        heapDump.computeRetainedHeapSize);<br>    AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);<br>  }</p>
<p>  @Override public void onProgressUpdate(Step step) {<br>    int percent = (int) ((100f * step.ordinal()) / Step.values().length);<br>    CanaryLog.d(“Analysis in progress, working on: %s”, step.name());<br>    String lowercase = step.name().replace(“_”, “ “).toLowerCase();<br>    String message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1);<br>    showForegroundNotification(100, percent, false, message);<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我们进入checkForLeak方法中发现最终</div></pre></td></tr></table></figure>
<p>Snapshot snapshot = parser.parse();<br>```<br>调用了这个对象来分析，这个是square公司出的HAHA分析库</p>
<p>总结：<br>LeakCanary原理</p>
<ol>
<li>首先通过application的registerActivityLifecycleCallbacks监听，在activity的 onDestroy中调用watch方法<br>2.watch方法中讲每一个activity引用放到一个WeakReference中</li>
<li>这个WeakReference关联到一个ReferenceQueue  </li>
<li>调用ensureGoneAsync方法:  查看ReferenceQueue是否存在 Activity的引用<br>该检测的流程：  </li>
</ol>
<p>1） 移除不可达引用，如果当前引用不存在了，则不继续执行 </p>
<p>2） 手动触发GC操作，gcTrigger中封装了gc操作的代码 </p>
<p>3） 再次移除不可达引用，如果引用不存在了，则不继续执行</p>
<p>4） 如果两次判定都没有被回收，则开始分析这个引用，最终生成HeapDump信息</p>
<ol>
<li>如果该Acitivty泄漏了，Dump出内存信息，再去分析泄漏路径 在1.6版本中主要使用HAHA库</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;首先判断当前线程是不是主线程，如果是分析LeakCanary的线程的话，就不应该初始化&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷题</title>
    <link href="http://yoursite.com/2019/05/19/LeetCode%E5%88%B7%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/19/LeetCode刷题/</id>
    <published>2019-05-18T16:00:00.000Z</published>
    <updated>2020-02-28T03:20:02.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从排序数组中删除重复项"><a href="#从排序数组中删除重复项" class="headerlink" title="从排序数组中删除重复项"></a>从排序数组中删除重复项</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>你可以想象内部操作如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></div><div class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</div><div class="line"></div><div class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></div><div class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">    print(nums[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我的思路</p>
<blockquote>
<p> 由于数组已经是有序的，所以我们只需要从0开始向后找到每一个更大的数，依次往下放就好了 ，  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> lenght=<span class="number">1</span>;</div><div class="line">         <span class="keyword">int</span> s=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;          </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=s;j&lt;nums.length;j++)&#123;     </div><div class="line">                    <span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</div><div class="line">                         s=j+<span class="number">1</span>;</div><div class="line">                         nums[i+<span class="number">1</span>]=nums[j];   </div><div class="line">                        lenght++;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i&lt;nums.length-<span class="number">1</span>&amp;&amp;nums[i]&gt;nums[i+<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lenght;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面添加的判断是由于当最大的数已经放好之后，后面的排列是不需要的，而最大数之后的数一定会比他小，所以才增加的,不然排列会出现问题  </p>
<h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<blockquote>
<p>这个方法可以用一个贪心法则来实现，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int maxProfit(int[] prices) &#123;</div><div class="line">        int profile=0;</div><div class="line">       for(int i=0;i&lt;prices.length-1;i++)&#123;</div><div class="line">           if(prices[i+1]&gt;prices[i])&#123;</div><div class="line">               profile=profile+prices[i+1]-prices[i];</div><div class="line">           &#125;</div><div class="line">              </div><div class="line">       &#125;</div><div class="line">        return profile;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">###  旋转数组</div><div class="line">给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</div><div class="line"></div><div class="line">示例 1:</div><div class="line"></div><div class="line">输入: [1,2,3,4,5,6,7] 和 k = 3  </div><div class="line">输出: [5,6,7,1,2,3,4]  </div><div class="line">解释:  </div><div class="line">向右旋转 1 步: [7,1,2,3,4,5,6]  </div><div class="line">向右旋转 2 步: [6,7,1,2,3,4,5]  </div><div class="line">向右旋转 3 步: [5,6,7,1,2,3,4]  </div><div class="line"></div><div class="line"></div><div class="line">尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</div><div class="line">要求使用空间复杂度为 O(1) 的原地算法。  </div><div class="line">思路</div><div class="line">&gt; 该问题有很多解法，最为巧妙的做法是1）将左半部分的数组整个旋转，然后将右半部分的数组整个旋转，最后旋转整个数组获得结果2）求得len和k的最大公约数 ，如没有则就为k，然后从下标0开始，加k进行替换，即nums[0]和nums[k-1]交换，nums[2k-1]和nums[k-1]交换，nums[0]用一直到整个数组都交换完毕后的位置代替3）将数组分为ab两部分，如果a比b大就分为a1a2b其中a1的个数和b相同，然后a1和b交换变为ba2a1然后在对a2a1继续进行分，，如果a比b小就分为ab1b2其中b2的个数和a相同，然后a和b2交换变为b2b1a然后在对b2b1继续进行分，直到分不了位置</div><div class="line">STL左旋转字符串Rotate的深入理解和自我实现4）按照题目进行k次循环，每次移动一位，最后得到移动K步的数组</div><div class="line"></div><div class="line">### 只出现一次的数字 </div><div class="line">给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</div><div class="line"></div><div class="line">说明：</div><div class="line"></div><div class="line">你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</div><div class="line"></div><div class="line">&gt; 示例 1:</div><div class="line"></div><div class="line">输入: [2,2,1]</div><div class="line">输出: 1</div><div class="line"></div><div class="line">&gt; 解答</div><div class="line">该问题通过异或运算符^可以很快得到答案，其运算规律为两个操作数的位中，相同则结果为0，不同则结果为1。所以我们对整个数组进行异或运算，最终结果就是单独的数字</div><div class="line">```java</div><div class="line">  public int singleNumber1(int[] nums) &#123;</div><div class="line">        int res = 0;</div><div class="line">        for (int i = 0; i &lt; nums.length; i = i + 1) &#123;</div><div class="line">            res ^= nums[i];</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h3><p>给定两个数组，写一个方法来计算它们的交集。</p>
<p>例如:<br>给定 nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2, 2].</p>
<p>注意：</p>
<p>   输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。<br>   我们可以不考虑输出结果的顺序。<br>跟进:</p>
<p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果nums2的元素存储在磁盘上，内存是有限的，你不能一次加载所有的元素到内存中，你该怎么办？<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div></pre></td><td class="code"><pre><div class="line">  //思路 先对两个数组进行排序，后循环，循环过程中如果1&gt;2那么2+1如果1&lt;2那么1+1</div><div class="line">    public int[] intersect(int[] nums1, int[] nums2) &#123;</div><div class="line">        int[] res = new int[nums2.length];</div><div class="line">        if (nums2.length == 0 || nums1.length == 0) return new int[]&#123;&#125;;</div><div class="line">        Arrays.sort(nums1);</div><div class="line">        Arrays.sort(nums2);</div><div class="line">        int point = 0;</div><div class="line">        int start = 0;</div><div class="line">        for (int i = 0; i &lt; nums2.length; i++) &#123;</div><div class="line">            for (int j = start; j &lt; nums1.length; j++) &#123;</div><div class="line">                if (nums2[i] == nums1[j]) &#123;</div><div class="line">                    res[point++] = nums2[i];</div><div class="line">                    start = ++j;</div><div class="line">                    break;</div><div class="line">                &#125; else if (nums2[i] &lt; nums1[j]) &#123;</div><div class="line">                    start = j;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (point == 0) &#123;</div><div class="line">            return new int[]&#123;&#125;;</div><div class="line">        &#125; else &#123;</div><div class="line">            int[] result = Arrays.copyOfRange(res, 0, point);</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    //思路 先把数组1的值作为key放入map中，然后遍历nums2找map数组是否含有，有就插入数组中</div><div class="line">    public int[] intersects(int[] nums1, int[] nums2) &#123;</div><div class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</div><div class="line">        for (int n : nums1) &#123;</div><div class="line">            int num = map.get(n) != null ? map.get(n) : 0;</div><div class="line">            map.put(n, num + 1);</div><div class="line">        &#125;</div><div class="line">        for (int n : nums2) &#123;</div><div class="line">            int num = map.get(n) != null ? map.get(n) : 0;</div><div class="line">            if (num != 0) &#123;</div><div class="line">                res.add(n);</div><div class="line">                map.put(n, num - 1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        int[] result = new int[res.size()];</div><div class="line">        for (int i = 0; i &lt; res.size(); i++) &#123;</div><div class="line">            result[i] = res.get(i);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">```  </div><div class="line"></div><div class="line"></div><div class="line">**根据这几道题可以得出一个经验，当我们需要对一串数字找到独一无二的那个的时候，就可以使用异或，而针对于两个数组的时候，我们就可以通过创建一个map数组来遍历查找**  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### 有效的数独  </div><div class="line"></div><div class="line"> 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</div><div class="line"></div><div class="line"> 数字 1-9 在每一行只能出现一次。  </div><div class="line"> 数字 1-9 在每一列只能出现一次。  </div><div class="line"> 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。  </div><div class="line"></div><div class="line"> 示例 1:  </div><div class="line"></div><div class="line"> 输入:  </div><div class="line"> [  </div><div class="line"> ["5","3",".",".","7",".",".",".","."],  </div><div class="line"> ["6",".",".","1","9","5",".",".","."],  </div><div class="line"> [".","9","8",".",".",".",".","6","."],  </div><div class="line"> ["8",".",".",".","6",".",".",".","3"],  </div><div class="line"> ["4",".",".","8",".","3",".",".","1"],  </div><div class="line"> ["7",".",".",".","2",".",".",".","6"],  </div><div class="line"> [".","6",".",".",".",".","2","8","."],  </div><div class="line"> [".",".",".","4","1","9",".",".","5"],  </div><div class="line"> [".",".",".",".","8",".",".","7","9"]  </div><div class="line"> ]  </div><div class="line"> 输出: true</div><div class="line"> </div><div class="line">```java</div><div class="line">  /**该问题即为，查找行列块中是否有相同元素，可以声明一个与被查询的列相同大小的数组，将第一个要查询的、</div><div class="line">   数字插入数组中，随后把第二个数字插入数组中，数组的值可以作为数组的下标，如果相同下标的数组有值，那就是有重复的</div><div class="line">  对于块而言，由于双重循环，就变成把&#123;&#123;0,0&#125;，&#123;0,1&#125;，&#123;0,2&#125;，&#123;0,3&#125;...&#125;如何转话为块中的元素</div><div class="line">   可得公式为  int cubeX = 3 * (i/3) + j/3;</div><div class="line">   int cubeY = 3 * (i%3) + j%3;</div><div class="line">   */</div><div class="line">    public static boolean isValidSudoku(char[][] board) &#123;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; board.length; i++) &#123;</div><div class="line">            boolean[] col = new boolean[board.length];</div><div class="line">            boolean[] row = new boolean[board.length];</div><div class="line">            boolean[] block = new boolean[board.length];</div><div class="line">            for (int j = 0; j &lt; board.length; j++) &#123;</div><div class="line">                if (board[i][j] != '.') &#123;</div><div class="line">                    if (row[board[i][j] - '1']) &#123;</div><div class="line">                        return false;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        row[board[i][j] - '1'] = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (board[j][i] != '.') &#123;</div><div class="line">                    if (col[board[j][i] - '1']) &#123;</div><div class="line">                        return false;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        col[board[j][i] - '1'] = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                int x = 3 * (i / 3) + j / 3;</div><div class="line">                int y = 3 * (i % 3) + j % 3;</div><div class="line">                if (board[x][y] != '.') &#123;</div><div class="line"></div><div class="line">                    if (block[board[x][y] - '1']) &#123;</div><div class="line">                        return false;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        block[board[x][y] - '1'] = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"> ```  </div><div class="line"> </div><div class="line">**对于查询数组重复值的问题，可以声明一个新数组，将数组的值作为新数组的下标，之后如果查询到该下标有值，就证明有重复的数字了**</div><div class="line"></div><div class="line">### 反转字符串 11</div><div class="line">编写一个函数，其作用是将输入的字符串反转过来。  </div><div class="line">示例：  </div><div class="line">&gt; 输入: "A man, a plan, a canal: Panama"  </div><div class="line">输出: "amanaP :lanac a ,nalp a ,nam A"  </div><div class="line">**如果效率要最高，应该把字符串转换为字节数组，对字节数组进行倒序**</div><div class="line">```java</div><div class="line">  public static String reverseString1(String s) &#123;</div><div class="line">        char[] chars = s.toCharArray();</div><div class="line">        int i = 0;</div><div class="line">        int j = chars.length - 1;</div><div class="line">        while (i &lt; j) &#123;</div><div class="line">            char temp = chars[i];</div><div class="line">            chars[i] = chars[j];</div><div class="line">            chars[j] = temp;</div><div class="line">            i++;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return new String(chars);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">```  </div><div class="line"></div><div class="line">### 环形链表  </div><div class="line">给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</div><div class="line"></div><div class="line">说明：不允许修改给定的链表。</div><div class="line"></div><div class="line">对于判断一个链表是不是环形，我们可以使用快慢指针法。  </div><div class="line">![image](https://note.youdao.com/yws/api/personal/file/50E2920AF0154C7CB5145EA375304EA5?method=download&amp;shareKey=867e1157078b508a3cf3c5f54b6261d7) </div><div class="line">如图，设从head到环形开始结点的距离是A，慢指针从环形开始结点走到相遇点走过的路程是B，环的长度是L（画图的时候漏掉了，图中没有标示出来）。于是有：</div><div class="line"></div><div class="line">对慢指针，从head走到meet的距离为A+B  </div><div class="line">对快指针，从head走到meet的距离为2A+2B（因为快指针的速度是慢指针的两倍，而在相遇时它们走了相同的时间）  </div><div class="line">相遇时，慢指针被快指针套了一圈，即快指针比慢指针多走一圈  </div><div class="line">根据以上分析我们可以列一个等式：A+B+L = 2A+2B，可以解得L = A + B。从这个结果可以看出，meet到begin的距离也是A。这意味着，如果我们分别放两个指针在head和meet，让它们以相同的速度前进，它们第一次相遇的地方就是我们要找的环形开始结点。    </div><div class="line">```java</div><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123;</div><div class="line"> *         val = x;</div><div class="line"> *         next = null;</div><div class="line"> *     &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public ListNode detectCycle(ListNode head) &#123;</div><div class="line">          if(head==null) return null;</div><div class="line">        ListNode slowP=head.next;</div><div class="line">        ListNode quickP;</div><div class="line">        if(slowP!=null) quickP=slowP.next; else return null;</div><div class="line">        while(quickP!=slowP)&#123;</div><div class="line">            if(quickP!=null &amp;&amp; quickP.next!=null)</div><div class="line">              quickP=quickP.next.next;</div><div class="line">            else </div><div class="line">                return null;</div><div class="line">            slowP=slowP.next;</div><div class="line">        &#125; </div><div class="line">       slowP=head;</div><div class="line">       while(quickP!=slowP)&#123;</div><div class="line">            if(quickP!=null &amp;&amp; quickP.next!=null)</div><div class="line">              quickP=quickP.next;</div><div class="line">            else </div><div class="line">                return null;</div><div class="line">            slowP=slowP.next;</div><div class="line">        &#125; </div><div class="line">        </div><div class="line">        return quickP;</div><div class="line"></div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;从排序数组中删除重复项&quot;&gt;&lt;a href=&quot;#从排序数组中删除重复项&quot; class=&quot;headerlink&quot; title=&quot;从排序数组中删除重复项&quot;&gt;&lt;/a&gt;从排序数组中删除重复项&lt;/h3&gt;&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>weex 踩坑记录</title>
    <link href="http://yoursite.com/2019/05/15/weex%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/05/15/weex 踩坑记录/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2020-02-28T03:26:50.164Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>web控件ios的src是不能接受中文的 ，需要通过ecode转码  </li>
<li>函数里套用函数 一定要把this赋值给某个变量后使用，不然 o(╥﹏╥)o  </li>
<li>ios如果调用原生方法有问题，直接下一步就进行不了，但是安卓还是可以往下运行  </li>
<li><p>:class不能使用对象语法应该使用数组语法，数组写法  </p>
<figure class="highlight plain"><figcaption><span>=== 'index' ? 'active' : '']"```  </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">且数组写法一次只能判断添加一个类</div><div class="line">5. input组件有数据后，再赋值一个null或者undefined，组件内容不会置空，所以需要对赋值数据判断，无数据就赋值空字符串</div><div class="line">6. weex对于一个对象增加元素和删除元素是无感知的例如 student=&#123;name:11&#125;  而html中展示使用了name和age字段，当我们进行age赋值使用student.age=xxx这时候页面状态不会变化，因为weex感知不到元素增加了。 所以最好的办法就是在声明对象的时候 把所有的元素都声明上，然后赋值的时候使用</div></pre></td></tr></table></figure>
<pre><code>Object.assign(this.carInfo, info);
for (let key in this.carInfo) {
    if (info[key] == undefined) {
        this.carInfo[key] = &quot;&quot;
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这样的赋值方法 不会丢失对象中的任何一个元素，新增的元素也能立马得到响应  </div><div class="line">7. 在Android中如果连续调用了两个weex提供的toast，会导致toast无法显示</div><div class="line">8. 有时候weex高度自适应会出问题 ，这时候外层套用div flex1可以解决，比如tabpage中如果有list本来是需要自己写明高度的，但是如果套用的div的话, list的高度是可以被计算出来的</div></pre></td></tr></table></figure>
</li>
</ol>
<p><div class="flex1"><br>        <tabpage ref="wxc-tab-page" class="flex1" :tab-titles="tabTitles" :tab-styles="tabStyles" title-type="text" @click="openFilter"></tabpage></div></p>
<pre><code>    &lt;div class=&quot;flex_row&quot;&gt;
         &lt;list ref=&quot;list&quot; @loadmore=&quot;onloading(index)&quot; loadmoreoffset=&quot;10&quot;
                  :key=&quot;index&quot;
                  style=&quot;width: 750px&quot;
                  v-for=&quot;(v,index) in tabList&quot;
                  class=&quot;item-container&quot;&gt;
        &lt;/list&gt;
     &lt;/div&gt;
&lt;/TabPage&gt;
</code></pre><p><div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">9. weex在Android中如果遇到中英文混排的时候，如果一行内容不够，而且一行的最后一个字母是数字或者英文，则会在中英文中间强制换行，例如haha1111如果一行显示不下 在weex中就会显示为  </div><div class="line">haha  </div><div class="line">1111这种形式 如果我们限制显示一行末尾省略号，就会变成hah...显示错误，目前暂无解决方案</div></pre></td></tr></table></figure></div></p>
<p>Android compatibility</p>
<p>一般来说，在下列场景下你可能会遇到 word-break 在不同机器上不一致的现象：</p>
<ul>
<li><p>中文/日文/韩文(即 CJK 文字)与其他文字混合排布时，在 CJK 文字和其他文件相交区域可能会遇到 word-break 不一致的现象。   </p>
</li>
<li><p>全角非 JCK 文字和半角非 CJK 文字混合时，全角和半角相交的地方可能会遇到 word-break 不一致的现象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10. weex 下拉刷新的refresh组件中的display如果为true，在ios中列表会滚动到页面的最顶端来进行刷新，所以我们在判断数据刷新时，要记得单独判断一下display，避免一调用刷新页面就跑到上面去了</div></pre></td></tr></table></figure>
<p>  &lt;refresh class=”refresh”</p>
<pre><code>   @refresh=&quot;onrefresh(index,true)&quot;
  :display=&quot;v.autoRefreshing?&apos;show&apos;:&apos;hide&apos;&quot;&gt;
&lt;loading-indicator class=&quot;indicator&quot;&gt;&lt;/loading-indicator&gt;
</code></pre><p>  <br>```</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;web控件ios的src是不能接受中文的 ，需要通过ecode转码  &lt;/li&gt;
&lt;li&gt;函数里套用函数 一定要把this赋值给某个变量后使用，不然 o(╥﹏╥)o  &lt;/li&gt;
&lt;li&gt;ios如果调用原生方法有问题，直接下一步就进行不了，但是安卓还是可以往下运
    
    </summary>
    
      <category term="weex" scheme="http://yoursite.com/categories/weex/"/>
    
    
  </entry>
  
  <entry>
    <title>java的值传递</title>
    <link href="http://yoursite.com/2019/04/25/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2019/04/25/java的值传递/</id>
    <published>2019-04-24T16:00:00.000Z</published>
    <updated>2020-02-28T03:51:35.727Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/31203609" target="_blank" rel="external">https://www.zhihu.com/question/31203609</a>  Yolanda</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/31203609&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/31203609&lt;/a&gt;  Yolanda&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>OkHttp</title>
    <link href="http://yoursite.com/2019/04/12/OkHttp/"/>
    <id>http://yoursite.com/2019/04/12/OkHttp/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2020-02-28T03:21:03.725Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发、地阻塞的操作。</li>
<li>OkHttp采用队列进行缓存，按照入列的特点先进先出来执行任务</li>
<li>OkHttp最出彩的地方就是在try/finally中调用了finish函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大的减少了编码的复杂性，finish方法中做了两个主要操作：空闲出多余线程，调用promoteCalls调用待执行的任务；<br>如果当前整个线程池都空闲下来，执行空闲通知回调线程(idleCallback)</li>
</ol>
<p>okHttp中创建了一个线程池<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</div><div class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</div><div class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> executorService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该线程池的最大主线程数为0，允许的最大任务队列无限大，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做”OkHttp Dispatcher”的线程工厂。<br>也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。</p>
<p>通过dispatch来分发需要执行的操作</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发、地阻塞的操作。&lt;/li&gt;
&lt;li&gt;OkHttp采用队列进行缓存，按照入列的特点先进先出来执行任务&lt;/li&gt;
&lt;li&gt;OkHttp最出彩的地方就是在try/finally中调用了
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://yoursite.com/2019/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/10/数据结构/</id>
    <published>2019-03-09T16:00:00.000Z</published>
    <updated>2020-02-28T03:45:24.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向  </p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组（Array）是一种==线性表==数据结构。它用一组==连续的内存空间==，来存储一组具有==相同类型的数据==，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。<br>数组是如何实现根据下标随机访问数组元素的 ？<br>计算机会给每个内存单位分配一个地址，计算机通过地址来访问内存中的数据，当计算机需要通过下标随机访问数组中的某个元素时，他会先通过寻址公式，计算出该元素存储的内存地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[i]_address = base_address（数组的首地址） + i * data_type_size（存储的数据类型的字节数）</div></pre></td></tr></table></figure>
<p>ArrayList的底层也是用数组实现的，但他相对于数组有一些优势：可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等；支持动态扩容<br>对于数组而言，我们指定大小之后是不能改变的，数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来数据复制过去，然后再将新的数据插入。    </p>
<p>那什么时候使用数组比较好  </p>
<ol>
<li>ArrayList不支持基本数据类型，一般都需要装箱后才能使用，如果有性能需求时，就可以使用数组  </li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList 提供的大部分方法，也可以直接使用数组。  </li>
</ol>
<p>实际，除非对性能有很高的追求，一般使用容器就可以  </p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>单链表<br>双向链表<br>循环链表</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>对于排序算法的好坏 我们可以从多个方面分析  </p>
<ol>
<li>算法的执行效率<br>最好情况，最快情况以及平均情况时间复杂度<br>时间复杂度的系数、常数 、低阶<br>比较次数和交换（或移动）次数  </li>
<li>排序算法的内存消耗（空间复杂度）   </li>
<li>排序算法的稳定性<br>如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之后，相等元素之间原有的先后顺序不变。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;p&gt;数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向  &lt;/p&gt;
&lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Android应用保活</title>
    <link href="http://yoursite.com/2019/02/11/%E5%BA%94%E7%94%A8%E4%BF%9D%E6%B4%BB/"/>
    <id>http://yoursite.com/2019/02/11/应用保活/</id>
    <published>2019-02-10T16:00:00.000Z</published>
    <updated>2020-02-28T03:23:29.978Z</updated>
    
    <content type="html"><![CDATA[<p>对于Android应用保活我们要分成两个方面考虑</p>
<ol>
<li>当提高进程Service的oom_adj值，以降低其被系统回收的几率，Android系统会根据当前系统资源和进程oom_adj值来回收相应的进程,前台进程的oom_adj一般为0，  </li>
</ol>
<ul>
<li>在屏幕上留下1像素的activity就是通过将进程保持在前台进程进行保活的  </li>
<li>使用startForeground（）方法创建一个在前台运行的service，对API大于18而言 startForeground()方法需要弹出一个可见通知，可以开启另一个Service将通知栏移除，其oom_adj值还是没变的<blockquote>
<p>当系统锁屏时间过长时，应用会被杀死<br>1.可以采取在锁屏的时候启动一个1个像素的Activity，当用户解锁以后将这个Activity结束掉（顺便同时把自己的核心服务再开启一次）。被用户发现了就不好了。<br>背景：当手机锁屏的时候什么都干死了，为了省电。<br>锁屏界面在上面盖住了。<br>监听锁屏广播，锁了—启动这个Activity。<br>监听锁屏的，  开启—结束掉这个Activity。<br>要监听锁屏的广播—动态注册。<br>2.app运营商和手机厂商可能有合作关系—白名单。<br>3.双进程守护—可以防止单个进程杀死，同时可以防止第三方的360清理掉。一个进程被杀死，另外一个进程又被他启动。相互监听启动。<br> A&lt;—&gt;B   杀进程是一个一个杀的。本质是和杀进程时间赛跑。<br>4.JobScheduler 5.0以下没有<br>把任务加到系统调度队列中，当到达任务窗口期的时候就会执行，我们可以在这个任务里面启动我们的进程。这样可以做到将近杀不死的进程。<br>5.监听QQ,微信，系统应用，友盟，小米推送等等的广播，然后把自己启动了。<br>6.利用账号同步机制唤醒我们的进程   AccountManager<br>7.NDK来解决，Native进程来实现双进程守护。<br>总结：要根据自己的需要来使用。 </p>
</blockquote>
</li>
</ul>
<ol>
<li>自启动，申请应用管家自启动权限  </li>
<li>忽略电池优化，申请加入电池白名单 防止app被杀死</li>
<li>doze模式下会有延迟，加入闹钟</li>
<li>workmanager  alarmmanager </li>
</ol>
<p>提醒业务逻辑<br>1.设备进行蓝牙连接后：<br>可以对设备进行蓝牙目标设置，三个目标模式 低强度 60min,均衡 45min ，高强度 30min，增加一个自定义模式？<br>用户打开app 进行连接后，可以对提醒方式进行设置，然后点击open开始 ，我们计时，假设每30min给他一个推送  ，叫他站起来<br>然后下次进入app的时候 这个默认的关闭的 ？？<br>close也可以对这个提醒进行关闭</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于Android应用保活我们要分成两个方面考虑&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当提高进程Service的oom_adj值，以降低其被系统回收的几率，Android系统会根据当前系统资源和进程oom_adj值来回收相应的进程,前台进程的oom_adj一般为0，  &lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android开发手册摘要</title>
    <link href="http://yoursite.com/2019/01/12/Android%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E6%91%98%E8%A6%81/"/>
    <id>http://yoursite.com/2019/01/12/Android开发手册摘要/</id>
    <published>2019-01-11T16:00:00.000Z</published>
    <updated>2020-02-28T03:19:04.395Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>避免在 Service#onStartCommand()/onBind()方法中执行耗时操作，如果确<br>实有需求，应改用 IntentService 或采用其他异步机制完成，intentservice会在oncreate中新开启一个线程，</p>
</li>
<li><p>避免在 BroadcastReceiver#onReceive()中执行耗时操作，如果有耗时工作，<br>应该创建 IntentService 完成，而不应该在 BroadcastReceiver 内创建子线程去做。</p>
</li>
<li><p>避免使用隐式 Intent 广播敏感信息，信息可能被其他注册了对应<br>BroadcastReceiver 的 App 接收；通过 Context#sendBroadcast()发送的隐式广播会被所有感兴趣的 receiver 接收，恶<br>意应用注册监听该广播的 receiver 可能会获取到 Intent 中传递的敏感信息，并进行<br>其他危险操作。如果发送的广播为使用 Context#sendOrderedBroadcast()方法发送<br>的有序广播，优先级较高的恶意 receiver 可能直接丢弃该广播，造成服务不可用，<br>或者向广播结果塞入恶意数据。<br>如果广播仅限于应用内，则可以使用 LocalBroadcastManager#sendBroadcast()实<br>现，避免敏感信息外泄和 Intent 拦截的风险</p>
</li>
<li><p>添 加 Fragment 时 ， 确 保 FragmentTransaction#commit() 在<br>Activity#onPostResume()或者 FragmentActivity#onResumeFragments()内调用。<br>不要随意使用 FragmentTransaction#commitAllowingStateLoss()来代替，任何<br>commitAllowingStateLoss()的使用必须经过 code review，确保无负面影响；Activity 可 能 因 为 各 种 原 因 被 销 毁 ， Android 支 持 页 面 被 销 毁 前 通 过<br>Activity#onSaveInstanceState() 保 存 自 己 的 状 态 。 但 如 果<br>FragmentTransaction.commit()发生在 Activity 状态保存之后，就会导致 Activity 重建、恢复状态时无法还原页面状态，从而可能出错。为了避免给用户造成不好的体<br>验，系统会抛出 IllegalStateExceptionStateLoss 异常。推荐的做法是在 Activity 的onPostResume() 或 onResumeFragments() （ 对 FragmentActivity ） 里 执 行<br>FragmentTransaction.commit()，如有必要也可在 onCreate()里执行。不要随意改用<br>FragmentTransaction.commitAllowingStateLoss() 或 者 直 接 使 用 try-catch 避 免crash，这不是问题的根本解决之道，当且仅当你确认 Activity 重建、恢复状态时，<br>本次 commit 丢失不会造成影响时才可这么做</p>
</li>
<li>加载大图片或者一次性加载多张图片，应该在异步线程中进行。图片的加<br>载，涉及到 IO 操作，以及 CPU 密集操作，很可能引起卡顿</li>
<li>将 android:allowbackup 属性设置为 false，防止 adb backup 导出数据；在 AndroidManifest.xml 文件中为了方便对程序数据的备份和恢复在 Android API<br>level 8 以后增加了 android:allowBackup 属性值。默认情况下这个属性值为 true,故<br>当 allowBackup 标志值为 true 时，即可通过 adb backup 和 adb restore 来备份和恢复应用程序数据</li>
<li>对于内部使用的组件，显示设置组件的”android:exported”属性为 false。Android 应用使用 Intent 机制在组件之间传递数据，如果应用在使用 getIntent()，<br>getAction()，Intent.getXXXExtra()获取到空数据、异常或者畸形数据时没有进行异<br>常捕获，应用就会发生 Crash，应用不可使用（本地拒绝服务）。恶意应用可通过向<br>受害者应用发送此类空数据、异常或者畸形数据从而使应用产生本地拒绝服务  </li>
<li>依赖注入更多强调的是当某个类对于其他类有依赖时，该类不应该通过自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。而动态代理更多的是强调通过一个代理类，去实现原来的类的操作，常应用于AOP编程，不改变原来的类，就能进行某些方法拓展操作</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;避免在 Service#onStartCommand()/onBind()方法中执行耗时操作，如果确&lt;br&gt;实有需求，应改用 IntentService 或采用其他异步机制完成，intentservice会在oncreate中新开启一个线程，&lt;/p&gt;
&lt;/
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义View</title>
    <link href="http://yoursite.com/2018/12/18/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <id>http://yoursite.com/2018/12/18/自定义View/</id>
    <published>2018-12-18T06:01:11.660Z</published>
    <updated>2018-01-19T08:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义view"><a href="#自定义view" class="headerlink" title="自定义view"></a>自定义view</h1><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)</div><div class="line"> ``` </div><div class="line"> 进行测量   </div><div class="line">```Android</div><div class="line">int widthMode = MeasureSpec.getMode(widthMeasureSpec);  </div><div class="line">int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div></pre></td></tr></table></figure>
</li>
<li><p>onFinishInflate():从xml加载组件后回调</p>
</li>
<li>onSizeChanged():组件大小改变时回调</li>
<li>onLayout():确定显示的位置</li>
<li>onTouchEvent():监听到触摸事件时的回调</li>
</ul>
<a id="more"></a>
<h2 id="三种实现自定义控件的方法"><a href="#三种实现自定义控件的方法" class="headerlink" title="三种实现自定义控件的方法"></a>三种实现自定义控件的方法</h2><ol>
<li>对现有控件进行拓展</li>
<li>通过组合来实现新的控件</li>
<li>重写view来实现全新的控件</li>
</ol>
<h2 id="测量模式"><a href="#测量模式" class="headerlink" title="测量模式"></a>测量模式</h2><ol>
<li>UNSPECIFIED    父容器没有对当前View有任何限制，当前View可以任意取尺寸 </li>
<li>EXACTLY    当前的尺寸就是当前View应该取的尺寸   match_parent以及固定尺寸</li>
<li>AT_MOST    当前尺寸是当前View能取的最大尺寸  wrap_content<br>new Canvas(bitmap)canvas上的所有绘制都是基于bitmap上的</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自定义view&quot;&gt;&lt;a href=&quot;#自定义view&quot; class=&quot;headerlink&quot; title=&quot;自定义view&quot;&gt;&lt;/a&gt;自定义view&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; ``` &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 进行测量   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;```Android&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int widthMode = MeasureSpec.getMode(widthMeasureSpec);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int widthSize = MeasureSpec.getSize(widthMeasureSpec);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;onFinishInflate():从xml加载组件后回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;onSizeChanged():组件大小改变时回调&lt;/li&gt;
&lt;li&gt;onLayout():确定显示的位置&lt;/li&gt;
&lt;li&gt;onTouchEvent():监听到触摸事件时的回调&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>性能优化</title>
    <link href="http://yoursite.com/2018/12/15/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/12/15/性能优化/</id>
    <published>2018-12-14T16:00:00.000Z</published>
    <updated>2020-02-28T03:11:48.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="性能优化指标"><a href="#性能优化指标" class="headerlink" title="性能优化指标"></a>性能优化指标</h3><ol>
<li>渲染  </li>
</ol>
<ul>
<li>滑动流畅度：fps刷帧率一秒钟刷新帧数， 越接近60帧越好  </li>
<li>过度绘制：单页面的3X（粉红色区域） Overdraw小于25%  </li>
<li>启动时间：activity界面启动时间，一般低于300s<br>造成应用UI卡顿的常见原因</li>
</ul>
<ol>
<li>人为在UI线程中做轻微耗时操作，导致UI线程卡顿；</li>
<li>布局Layout过于复杂，无法在16ms内完成渲染；</li>
<li>同一时间动画执行的次数过多，导致CPU或GPU负载过重；</li>
<li>View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；</li>
<li>View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；</li>
<li>内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；</li>
<li>冗余资源及逻辑等导致加载和执行缓慢；</li>
<li>臭名昭著的ANR；</li>
</ol>
<p>Android系统每隔16ms发出VSYNC信号（vertical synchronization –场扫描同步，场同步，垂直同步），触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms（1000/60=16.67ms）内完成。  </p>
<p>优化步骤如下：<br>1、移除或修改Window默认的Background<br>2、移除XML布局文件中非必需的Background<br>3、按需显示占位背景图片<br>4、控制绘制区域  </p>
<ol>
<li>内存  </li>
</ol>
<ul>
<li>内存大小：峰值越低越好</li>
<li>内存泄漏</li>
</ul>
<ol>
<li>功耗  </li>
</ol>
<ul>
<li>单位时间内的掉电量，掉电量越少越好</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;性能优化指标&quot;&gt;&lt;a href=&quot;#性能优化指标&quot; class=&quot;headerlink&quot; title=&quot;性能优化指标&quot;&gt;&lt;/a&gt;性能优化指标&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;渲染  &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;滑动流畅度：fps刷帧率一秒钟刷新帧数， 越接
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Retrofit</title>
    <link href="http://yoursite.com/2018/11/02/retrofit/"/>
    <id>http://yoursite.com/2018/11/02/retrofit/</id>
    <published>2018-11-01T16:00:00.000Z</published>
    <updated>2020-02-28T03:46:24.143Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">api = <span class="keyword">new</span> Retrofit.Builder().client(client)</div><div class="line">         .addConverterFactory(GsonConverterFactory.create())</div><div class="line">         .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</div><div class="line">         .baseUrl(BuildConfig.API_URL_CYB)</div><div class="line">         .build()</div><div class="line">         .create(clazz);</div></pre></td></tr></table></figure>
<p>我们通过retrofit的构建来解析 他的组成<br>首先是retrofit对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</div><div class="line">  <span class="comment">// 网络请求配置对象（对网络请求接口中方法注解进行解析后得到的对象）</span></div><div class="line">  <span class="comment">// 作用：存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">// 网络请求器的工厂</span></div><div class="line">  <span class="comment">// 作用：生产网络请求器（Call）</span></div><div class="line">  <span class="comment">// Retrofit是默认使用okhttp</span></div><div class="line">  <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</div><div class="line">  <span class="comment">//url地址</span></div><div class="line">  <span class="keyword">final</span> HttpUrl baseUrl;</div><div class="line">  <span class="comment">//数据转化器工厂类集合，例如gson转化器</span></div><div class="line">  <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</div><div class="line">  <span class="comment">//网络请求适配器工厂类</span></div><div class="line">  <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; adapterFactories;</div><div class="line">  <span class="comment">//回调方法,默认回调方法执行器作用是：切换线程（子线程 - 主线程）</span></div><div class="line">  <span class="keyword">final</span> Executor callbackExecutor;</div><div class="line">  </div><div class="line">  <span class="comment">// 标志位</span></div><div class="line"><span class="comment">// 作用：是否提前对业务接口中的注解进行验证转换的标志位</span></div><div class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;</div><div class="line"></div><div class="line">  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</div><div class="line">      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories,</div><div class="line">      Executor callbackExecutor, <span class="keyword">boolean</span> validateEagerly) &#123;</div><div class="line">    <span class="keyword">this</span>.callFactory = callFactory;</div><div class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</div><div class="line">    <span class="keyword">this</span>.converterFactories = unmodifiableList(converterFactories);</div><div class="line">    <span class="keyword">this</span>.adapterFactories = unmodifiableList(adapterFactories); </div><div class="line">     <span class="comment">// unmodifiableList(list)近似于UnmodifiableList&lt;E&gt;(list)</span></div><div class="line">    <span class="comment">// 作用：创建的新对象能够对list数据进行访问，但不可通过该对象对list集合中的元素进行修改，只读</span></div><div class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</div><div class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h2><p>网络请求适配器<br>作用 ：将默认的网络请求执行器（OkHttpCall）转换成适合被不同平台来调用的网络请求执行器形式<br>假设RxJava2CallAdapterFactory可以将返回的call对象转换为Observable对象操作，方便了RXjava的使用而且不再需要使用handler来切换线程</p>
<h2 id="Bulider"><a href="#Bulider" class="headerlink" title="Bulider"></a>Bulider</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</div><div class="line">  <span class="keyword">private</span> okhttp3.Call.Factory callFactory;</div><div class="line">  <span class="keyword">private</span> HttpUrl baseUrl;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">private</span> Executor callbackExecutor;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</div><div class="line"></div><div class="line">  Builder(Platform platform) &#123;</div><div class="line">    <span class="keyword">this</span>.platform = platform;</div><div class="line">    <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></div><div class="line">    <span class="comment">// ensures correct behavior when using converters that consume all types.</span></div><div class="line">    converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(Platform.get());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Builder(Retrofit retrofit) &#123;</div><div class="line">    platform = Platform.get();</div><div class="line">    callFactory = retrofit.callFactory;</div><div class="line">    baseUrl = retrofit.baseUrl;</div><div class="line">    converterFactories.addAll(retrofit.converterFactories);</div><div class="line">    adapterFactories.addAll(retrofit.adapterFactories);</div><div class="line">    <span class="comment">// Remove the default, platform-aware call adapter added by build().</span></div><div class="line">    adapterFactories.remove(adapterFactories.size() - <span class="number">1</span>);</div><div class="line">    callbackExecutor = retrofit.callbackExecutor;</div><div class="line">    validateEagerly = retrofit.validateEagerly;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>使用建造者模式，生成一个retrofit对象，platform表示安卓平台  </p>
<h2 id="baseurl"><a href="#baseurl" class="headerlink" title=".baseurl()"></a>.baseurl()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(String baseUrl)</span> </span>&#123;</div><div class="line">   checkNotNull(baseUrl, <span class="string">"baseUrl == null"</span>);</div><div class="line">   HttpUrl httpUrl = HttpUrl.parse(baseUrl);</div><div class="line">   <span class="keyword">if</span> (httpUrl == <span class="keyword">null</span>) &#123;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal URL: "</span> + baseUrl);</div><div class="line">   &#125;</div><div class="line">    <span class="comment">// 最终返回带httpUrl类型参数的baseUrl（）</span></div><div class="line">   <span class="keyword">return</span> baseUrl(httpUrl);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(HttpUrl baseUrl)</span> </span>&#123;</div><div class="line">   checkNotNull(baseUrl, <span class="string">"baseUrl == null"</span>);</div><div class="line">   List&lt;String&gt; pathSegments = baseUrl.pathSegments();</div><div class="line">    <span class="comment">// 检测最后一个碎片来检查URL参数是不是以"/"结尾,不是就抛出异常    </span></div><div class="line">   <span class="keyword">if</span> (!<span class="string">""</span>.equals(pathSegments.get(pathSegments.size() - <span class="number">1</span>))) &#123;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"baseUrl must end in /: "</span> + baseUrl);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">this</span>.baseUrl = baseUrl;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="build"><a href="#build" class="headerlink" title=".build()"></a>.build()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//配置 网络请求器的工厂 默认为okhttpcall</span></div><div class="line">     okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</div><div class="line">     <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</div><div class="line">       callFactory = <span class="keyword">new</span> OkHttpClient();</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//配置回调方法执行器，默认是根据platform参数判断的</span></div><div class="line">     Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</div><div class="line">     <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">       callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">     &#125;</div><div class="line">     </div><div class="line"></div><div class="line">     <span class="comment">// 配置网络请求适配器，将系统默认的适配器加在最后</span></div><div class="line">     List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</div><div class="line">     adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line"></div><div class="line">      <span class="comment">// 配置数据转换适配器，默认第一个是系统默认的BuiltInConverters</span></div><div class="line">     List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</div><div class="line"></div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</div><div class="line">         callbackExecutor, validateEagerly);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>创建方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;-- 定义网络请求的接口类 --&gt;</div><div class="line">&lt;-- AccessApi.java --&gt;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessApi</span> </span>&#123;</div><div class="line">    <span class="comment">// 注解GET：采用Get方法发送网络请求</span></div><div class="line">    <span class="comment">// Retrofit把网络请求的URL分成了2部分：1部分baseurl放在创建Retrofit对象时设置；另一部分在网络请求接口设置（即这里）</span></div><div class="line">    <span class="comment">// 如果接口里的URL是一个完整的网址，那么放在创建Retrofit对象时设置的部分可以不设置</span></div><div class="line">    <span class="meta">@GET</span>(<span class="string">"openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car"</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 接受网络请求数据的方法</span></div><div class="line">    <span class="function">Call&lt;JavaBean&gt; <span class="title">getCall</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 返回类型为Call&lt;*&gt;，*是解析得到的数据类型，即JavaBean</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;-- 在MainActivity创建接口类实例  --&gt;</div><div class="line">AccessApi NetService = retrofit.create(AccessApi.class);</div><div class="line">       </div><div class="line">&lt;-- 对发送请求的url进行封装，即生成最终的网络请求对象  --&gt; </div><div class="line">        Call&lt;JavaBean&gt; call = NetService.getCall();</div></pre></td></tr></table></figure></p>
<h2 id="create"><a href="#create" class="headerlink" title=".create()"></a>.create()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line"><span class="comment">//判断该service是否合法</span></div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    <span class="comment">//如果为true，对service中的method进行提前验证</span></div><div class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">      eagerlyValidateMethods(service);</div><div class="line">      <span class="comment">// 具体方法作用：</span></div><div class="line">      <span class="comment">// 1. 给接口中每个方法的注解进行解析并得到一个ServiceMethod对象</span></div><div class="line">      <span class="comment">// 2. 以Method为键将该对象存入LinkedHashMap集合中</span></div><div class="line">     <span class="comment">// 特别注意：如果不是提前验证则进行动态解析对应方法（下面会详细说明），得到一个ServiceMethod对象，最后存入到LinkedHashMap集合中，类似延迟加载（默认）</span></div><div class="line">        &#125;</div><div class="line">    <span class="comment">//通过动态代理创建网络请求接口实例，该动态代理是为了拿到网络请求接口实例上所有注解</span></div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">         <span class="comment">// 在 InvocationHandler类的invoke（）实现中，除了执行真正的逻辑（如再次转发给真正的实现类对象），还可以进行一些有用的操作</span></div><div class="line">         <span class="comment">// 如统计执行时间、进行初始化和清理、对接口调用进行检查等。</span></div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line">              <span class="keyword">throws</span> Throwable &#123;</div><div class="line">            <span class="comment">// 如果是一个对象的方法就默认执行该方法</span></div><div class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">            &#125;</div><div class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>当netservice调用getcall方法时会进行拦截，调用都会转发到InvocationHandler的invoke方法中去<br>具体在invoke中其实就调用了三句方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">//该方法就是从serviceMethodCache中找有没有缓存的ServiceMethod方法，没有的话 就新创建一个</span></div><div class="line">   ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">    <span class="comment">//根据配置好的serviceMethod对象创建okHttpCall对象            </span></div><div class="line">    OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">    <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">  ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</div><div class="line">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</div><div class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</div><div class="line">      result = serviceMethodCache.get(method);</div><div class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">        result = <span class="keyword">new</span> ServiceMethod.Builder&lt;&gt;(<span class="keyword">this</span>, method).build();</div><div class="line">        serviceMethodCache.put(method, result);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//ServiceMethod的创建方式</span></div><div class="line">  <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="comment">// Upper and lower characters, digits, underscores, and hyphens, starting with a character.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String PARAM = <span class="string">"[a-zA-Z][a-zA-Z0-9_-]*"</span>;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Pattern PARAM_URL_REGEX = Pattern.compile(<span class="string">"\\&#123;("</span> + PARAM + <span class="string">")\\&#125;"</span>);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);</div><div class="line"> <span class="comment">//网络请求工厂</span></div><div class="line">  <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</div><div class="line">  / 网络请求适配器工厂</div><div class="line">  <span class="keyword">final</span> CallAdapter&lt;R, T&gt; callAdapter;</div><div class="line"><span class="comment">//为了请求地址</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpUrl baseUrl;</div><div class="line">  <span class="comment">// Response内容转换器  </span></div><div class="line">  <span class="comment">// 作用：负责把服务器返回的数据（JSON或者其他格式，由 ResponseBody 封装）转化为 R 类型的对象；</span></div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, R&gt; responseConverter;</div><div class="line">   <span class="comment">// 网络请求的Http方法  </span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String httpMethod;</div><div class="line">   <span class="comment">// 网络请求的相对地址</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String relativeUrl;</div><div class="line">  <span class="comment">//网络请求头</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</div><div class="line">  <span class="comment">// 网络请求的http报文body的类型  </span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MediaType contentType;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> hasBody;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isFormEncoded;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isMultipart;</div><div class="line">  <span class="comment">//方法参数处理器</span></div><div class="line">  <span class="comment">// 作用：负责解析 API 定义时每个方法的参数，并在构造 HTTP 请求时设置参数；</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ParameterHandler&lt;?&gt;[] parameterHandlers;</div><div class="line"></div><div class="line">  ServiceMethod(Builder&lt;R, T&gt; builder) &#123;</div><div class="line">    <span class="keyword">this</span>.callFactory = builder.retrofit.callFactory();</div><div class="line">    <span class="keyword">this</span>.callAdapter = builder.callAdapter;</div><div class="line">    <span class="keyword">this</span>.baseUrl = builder.retrofit.baseUrl();</div><div class="line">    <span class="keyword">this</span>.responseConverter = builder.responseConverter;</div><div class="line">    <span class="keyword">this</span>.httpMethod = builder.httpMethod;</div><div class="line">    <span class="keyword">this</span>.relativeUrl = builder.relativeUrl;</div><div class="line">    <span class="keyword">this</span>.headers = builder.headers;</div><div class="line">    <span class="keyword">this</span>.contentType = builder.contentType;</div><div class="line">    <span class="keyword">this</span>.hasBody = builder.hasBody;</div><div class="line">    <span class="keyword">this</span>.isFormEncoded = builder.isFormEncoded;</div><div class="line">    <span class="keyword">this</span>.isMultipart = builder.isMultipart;</div><div class="line">    <span class="keyword">this</span>.parameterHandlers = builder.parameterHandlers;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//生成网络请求适配器</span></div><div class="line">      callAdapter = createCallAdapter();</div><div class="line">      <span class="comment">//根据网络请求接口方法的返回值和注解类型，从Retrofit对象中获取该网络适配器返回的数据类型</span></div><div class="line">      responseType = callAdapter.responseType();</div><div class="line">      <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</div><div class="line">        <span class="keyword">throw</span> methodError(<span class="string">"'"</span></div><div class="line">            + Utils.getRawType(responseType).getName()</div><div class="line">            + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//生成数据转换适配器</span></div><div class="line">      responseConverter = createResponseConverter();</div><div class="line">    <span class="comment">// 解析网络请求接口中方法的注解</span></div><div class="line">      <span class="comment">// 主要是解析获取Http请求的方法，获取相对路径以及路径中的参数</span></div><div class="line">     <span class="comment">// 注解包括：DELETE、GET、POST、HEAD、PATCH、PUT、OPTIONS、HTTP、retrofit2.http.Headers、Multipart、FormUrlEncoded</span></div><div class="line">     <span class="comment">// 处理主要是调用方法 parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) ServiceMethod中的httpMethod、hasBody、relativeUrl、relativeUrlParamNames域进行赋值</span></div><div class="line"></div><div class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">        parseMethodAnnotation(annotation);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    </div><div class="line">     <span class="comment">// 获取方法中参数注解个数</span></div><div class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</div><div class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">      <span class="comment">//遍历参数，并将参数类型和参数注解类型以及位置放入parameterHandlers中</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</div><div class="line">        Type parameterType = parameterTypes[p];</div><div class="line">        <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</div><div class="line">          <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</div><div class="line">              parameterType);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class="line">        <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">     </div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  <span class="comment">//该adapter的创建就是上面第三句的serviceMethod.callAdapter</span></div><div class="line">    <span class="function"><span class="keyword">private</span> CallAdapter&lt;T, R&gt; <span class="title">createCallAdapter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//获取返回值类型</span></div><div class="line">      Type returnType = method.getGenericReturnType();</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</div><div class="line">        <span class="keyword">throw</span> methodError(</div><div class="line">            <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//返回值不能是void类型</span></div><div class="line">      <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</div><div class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Service methods cannot return void."</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//获取method上的注解</span></div><div class="line">      Annotation[] annotations = method.getAnnotations();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//获取retrofit中的第一个calladapter</span></div><div class="line">        <span class="keyword">return</span> (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</div><div class="line">      &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></div><div class="line">        <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">     <span class="function"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title">createResponseConverter</span><span class="params">()</span> </span>&#123;</div><div class="line">      Annotation[] annotations = method.getAnnotations();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</div><div class="line">      &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></div><div class="line">        <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create converter for %s"</span>, responseType);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当选择了RxjavaCallAdapterFactory后，Rxjava通过策略模式选择对应的adapter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;--  adapt（）详解--&gt;</div><div class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">Call&lt;R&gt; <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);  </div><div class="line">      &#125;</div><div class="line"></div><div class="line">   ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</div><div class="line">      <span class="keyword">this</span>.delegate = delegate; </div><div class="line">      <span class="comment">// 把上面创建并配置好参数的OkhttpCall对象交给静态代理delegate</span></div><div class="line">      <span class="comment">// 静态代理和动态代理都属于代理模式</span></div><div class="line">     <span class="comment">// 静态代理作用：代理执行被代理者的方法，且可在要执行的方法前后加入自己的动作，进行对系统功能的拓展</span></div><div class="line">      </div><div class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</div><div class="line">      <span class="comment">// 传入上面定义的回调方法执行器</span></div><div class="line">      <span class="comment">// 用于进行线程切换   </span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>NetService对象实际上是动态代理对象Proxy.newProxyInstance（），并不是真正的网络请求接口创建的对象<br>当NetService对象调用getCall（）时会被动态代理对象Proxy.newProxyInstance（）拦截，然后调用自身的InvocationHandler # invoke（）<br>invoke(Object proxy, Method method, Object… args)会传入3个参数：Object proxy:（代理对象）、<br>Method method（调用的getCall()）<br>Object… args（方法的参数，即getCall（<em>）中的</em>）<br>接下来利用Java反射获取到getCall（）的注解信息，配合args参数创建ServiceMethod对象。<br>最终创建并返回一个OkHttpCall类型的Call对象  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Retrofit采用了外观模式统一调用创建网络请求接口实例和网络请求参数配置的方法，具体细节是：</p>
<ul>
<li>动态创建网络请求接口的实例（代理模式 - 动态代理）</li>
<li>创建 serviceMethod 对象（建造者模式 &amp; 单例模式（缓存机制））</li>
<li>对 serviceMethod 对象进行网络请求参数配置：通过解析网络请求接口方法的参数、返回值和注解类型，从Retrofit对象中获取对应的网络请求的url地址、网络请求执行器、网络请求适配器 &amp; 数据转换器。（策略模式）</li>
<li>对 serviceMethod 对象加入线程切换的操作，便于接收数据后通过Handler从子线程切换到主线程从而对返回数据结果进行处理（装饰模式）</li>
<li>最终创建并返回一个OkHttpCall类型的网络请求对象</li>
</ul>
<h1 id="执行网络请求"><a href="#执行网络请求" class="headerlink" title="执行网络请求"></a>执行网络请求</h1><p>Retrofit默认使用OkHttp，即OkHttpCall类（实现了 retrofit2.Call<t>接口）<br>但可以自定义选择自己需要的Call类</t></p>
<p>OkHttpCall提供了两种网络请求方式：  </p>
<ul>
<li>同步请求：OkHttpCall.execute()</li>
<li>异步请求：OkHttpCall.enqueue()</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/18/设计模式/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2020-02-28T03:47:22.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四大原则"><a href="#四大原则" class="headerlink" title="四大原则"></a>四大原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类只有一个引起他变化的原因</p>
<h3 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h3><p>类,函数，模块等应该可以扩展，但不应该修改</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>高层模块不应该依赖底层模块，两者都应该依赖抽象<br>抽象不应该依赖细节，细节应该依赖抽象（针对接口编程，不要针对实现编程）</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且他察觉不出父类对象和子类对象的区别，也就是说，在软件里面，把父类都替换成他的子类，程序的行为没有变化</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>当我们要设计一个计算器应用的时候，我们可能使用了加减乘除操作符，但是当后期扩展时，加入平方根等操作符的时候，为了考虑程序的拓展性。我们可以使用工厂模式。<br> 工厂模式，利用面向对象语言的多态，利用一个工厂类，针对不同数据，创建出相对应的对象，而拓展时，我们只需要在工厂类中加入相应的判断和与之相对应的类就可以了。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> numA;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> numB;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getNumA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> numA;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumA</span><span class="params">(<span class="keyword">double</span> numA)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numA = numA;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getNumB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> numB;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumB</span><span class="params">(<span class="keyword">double</span> numB)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numB = numB;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//针对不同的数据创建出与之相对应的操作符对象</span></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String operation)</span> </span>&#123;</div><div class="line">        Operation mOperation = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">switch</span> (operation) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</div><div class="line">                mOperation = <span class="keyword">new</span> OperationAdd();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</div><div class="line">                mOperation = <span class="keyword">new</span> OperationSubtract();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:</div><div class="line">                mOperation = <span class="keyword">new</span> OperationMul();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:</div><div class="line">                mOperation = <span class="keyword">new</span> OperationDiv();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mOperation;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> numA + numB;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="工厂方法模式（多态工厂）—-list和set中的interator，activity的oncreate"><a href="#工厂方法模式（多态工厂）—-list和set中的interator，activity的oncreate" class="headerlink" title="工厂方法模式（多态工厂）—-list和set中的interator，activity的oncreate"></a>工厂方法模式（多态工厂）—-list和set中的interator，activity的oncreate</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类<br>简单工厂模式的优势在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，不需要与具体的业务逻辑类依赖。但是当我们需要扩展时，需要相应的去增加工厂类中的逻辑判断，这违背了开发-封闭原则，所以引入了工厂方法模式。<br>实际工厂方法模式相对于简单工厂模式对于每个子类都创建了相应的工厂类，在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">createOperation</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAddFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">createOperation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在客户端时，我们根据自己的需求，生成相对应的工厂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calcutor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        IFactory factory = <span class="keyword">new</span> OperationAddFactory();</div><div class="line">        Operation operation = factory.createOperation();</div><div class="line">        operation.numA = <span class="number">2</span>;</div><div class="line">        operation.numB = <span class="number">3</span>;</div><div class="line">        operation.getResult();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 针对工厂方法模式中我们需要写明需要生成的对象的类型，实际我们可以通过使用反射，通过反射，我们可以利用类名反射得到这个类的对象，我们可以将需要的类名配置在xml中，以后需要修改的时候，只用修改xml文件的类名即可，这样方便我们如果进行大量修改时，可以一步实现<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectFactory</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> &lt;T extends Operation&gt; <span class="function">T <span class="title">createOperation</span><span class="params">(Class&lt;T&gt; tClass)</span> </span>&#123;</div><div class="line">    <span class="comment">//这里传入的类型可以直接换成传入类的字符串名字</span></div><div class="line">        Operation operation = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            operation = (Operation) Class.forName(tClass.getName()).newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (T) operation;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="抽象工厂模式-——-mediaPlayer"><a href="#抽象工厂模式-——-mediaPlayer" class="headerlink" title="抽象工厂模式 ——-mediaPlayer"></a>抽象工厂模式 ——-mediaPlayer</h2><p>提供一个创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类<br>有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象，这时候 我们可以使用抽象工厂模式，假设，现在有个手机工厂，其子类有oppo ，vivo，小米。我们在使用工厂方法模式的时候，会建立一个小米工厂来生成手机，但是横向上，可能小米还生产耳机，等等多个产品，使用我们的这个工厂可以生成多种产品。<br>耳机类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HeadSet</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VivoHeadSet</span> <span class="keyword">implements</span> <span class="title">HeadSet</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">"use vivo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OppoHeadSet</span> <span class="keyword">implements</span>  <span class="title">HeadSet</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">"use oppo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>手机类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OppoPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">"use oppo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VivoPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">"use vivo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>工厂生产<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> HeadSet <span class="title">createHeadSet</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VivoFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VivoPhone();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> HeadSet <span class="title">createHeadSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VivoHeadSet();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OppoFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OppoPhone();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> HeadSet <span class="title">createHeadSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OppoHeadSet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        IFactory factory = <span class="keyword">new</span> OppoFactory();</div><div class="line">        HeadSet headSet = factory.createHeadSet();</div><div class="line">        Phone phone = factory.createPhone();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p> 策略模式用来封装算法，只要在不同时间需要运用不同的算法，业务规则时，就可以考虑使用策略模式来处理变化的可能性<br> 他和工厂模式的实现很相似，但工厂模式用来创建对象，是创建型的设计模式，它接受指令，创建出符合要求的实例即类对象；而策略模式可以表示可替换的算法等，是行为型的设计模式，它接受已经创建好的实例，实现不同的行为。工厂模式封装对象，实例化对象后调用的时候要知道具体的方法，策略模式封闭的是行为，调用的时候必须先指定实例化具体的类，再调用抽象的方法。<br>例如，对于一个商城，经常会进行打折活动，而每次打折方法都不一定，有可能打4折，有时候是满300减50，对于不同的打折我们就需要进行不同的计算，得到最后的价格，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">(    <span class="keyword">double</span> money)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountB</span> <span class="keyword">extends</span> <span class="title">Discount</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> num;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscountB</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.num = num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> money * num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountStrategy</span> </span>&#123;</div><div class="line">    Discount mDiscount;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscountStrategy</span><span class="params">(Discount discount)</span> </span>&#123;</div><div class="line">      mDiscount=discount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">caluatePrice</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mDiscount.getTotalPrice(money);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个就是策略模式，当我们需要使用不同折扣时，还是需要在客户端进行判断使用何种折扣，所以我们可以把策略模式和工厂模式结合起来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountStrategy</span> </span>&#123;</div><div class="line">    Discount mDiscount;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscountStrategy</span><span class="params">(String method)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (method) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"原价"</span>:</div><div class="line">                mDiscount = <span class="keyword">new</span> DiscountA();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"5折"</span>:</div><div class="line">                mDiscount = <span class="keyword">new</span> DiscountB(<span class="number">0.5</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">caluatePrice</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mDiscount.getTotalPrice(money);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时，我们只要对不同方法调用不同折扣即可  </p>
<h3 id="策略模式的缺点"><a href="#策略模式的缺点" class="headerlink" title="策略模式的缺点"></a>策略模式的缺点</h3><p>　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p>
<p>　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。
　　</p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>动态的给一个对象添加一些额外的职责<br>他不使用继承，而是使用添加对象，讲究的是一个动态性，可以自主对一个对象增加你需要的职责，也可以按照你想要的顺序来实现，新加入的东西可能仅仅是为了满足在一些只有特定情况下才会执行的特殊行为的需求，而装饰模式却提供了非常好的解决方法，它把每个要装饰的功能单独的放在单独的类中，因此，当需要执行特殊行为时，客户就可以在运行时根据需要有选择，按顺序的使用装饰功能包装对象。<br>首先我们需要抽象我们要装饰的对象，这一步可以省略，直接使用实体类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="comment">//需要装饰的操作</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">Operate</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//需要装饰的实体类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"早上起床"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>装饰抽象类，继承自需要装饰的类的原因我感觉是因为可以构成一个链式结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorate</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Component mComponent;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorate</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        mComponent = component; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        mComponent.Operate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对对象的装饰<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorateA</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecorateA</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(component);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.Operate();</div><div class="line">        addBehavior();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBehavior</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"刷牙"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当使用的时候 ，我们可以对需要装饰的对象外层装饰若干装饰类对象，可以根据需求动态改变顺序，根据不同顺序会得到不同的装饰后的实体类，这也是装饰器模式的优势<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Use &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Component component;</div><div class="line">        component = new DecorateA(new DecorateB(new ConcreteComponent()));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>给某一个对象提供一个代理，并由代理对象控制对原对象的引用<br>当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为保证客户端的透明性，委托对象与代理对象需要实现相同的接口</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>首先，我们需要抽象出委托对象需要代理的行为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>委托对象要实现上述接口，并实现相应的操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"送花"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而对于代理对象，只需要在自己的类中使用委托对象作出相应的操作即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    RealSubject mRealSubject;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mRealSubject == <span class="keyword">null</span>)</div><div class="line">            mRealSubject = <span class="keyword">new</span> RealSubject();</div><div class="line">        mRealSubject.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终，当我们调用的时候实际是通过代理对象来间接访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Use</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</div><div class="line">        proxy.doSomething();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述为静态代理方法<br>如果在编译期间我们无法预测要代理类要执行什么操作，这时候我们可以使用动态代理，<br>动态代理分为两种 ：Jdk动态代理实现和cgLib的动态代理实现。<br>这两者的区别在于Jdk动态代理实现是需要基于接口实现的    </p>
<h4 id="Jdk动态代理实现"><a href="#Jdk动态代理实现" class="headerlink" title="Jdk动态代理实现"></a>Jdk动态代理实现</h4><p>首先，我们需要抽象出委托对象需要代理的行为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILawSuit</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(String proof)</span></span>;<span class="comment">//提起诉讼</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span></span>;<span class="comment">//法庭辩护</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>委托类实现代理行为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuiHuaNiu</span> <span class="keyword">implements</span> <span class="title">ILawSuit</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(String proof)</span> </span>&#123;</div><div class="line">        System.out.println(String.format(<span class="string">"老板欠薪跑路，证据如下：%s"</span>,proof));</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(String.format(<span class="string">"铁证如山，%s还牛翠花血汗钱"</span>,<span class="string">"马旭"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个动态代理类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynProxyLawyer</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object target;<span class="comment">//被代理的对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynProxyLawyer</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.target=obj;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"案件进展："</span>+method.getName());</div><div class="line">        Object result=method.invoke(target,args);<span class="comment">//根据方法名执行方法</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">       InvocationHandler handler = <span class="keyword">new</span> DynProxyLawyer(target);</div><div class="line">       Object target=<span class="keyword">new</span> CuiHuaNiu();</div><div class="line">       ILawSuit proxy= (ILawSuit) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</div><div class="line">       proxy.submit(<span class="string">"工资流水在此"</span>);</div><div class="line">       proxy.defend();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>动态代理通过使用InvocationHandler接口以及Proxy创建代理类，InvocationHandler接口是给动态代理类实现的，负责处理被代理对象的操作的，而Proxy是用来创建动态代理类实例对象的，因为只有得到了这个对象我们才能调用那些需要代理的方法  </p>
<h4 id="cgLib的动态代理实现"><a href="#cgLib的动态代理实现" class="headerlink" title="cgLib的动态代理实现"></a>cgLib的动态代理实现</h4><p>定义业务类 ，不需要使用接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Frank</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(String proof)</span> </span>&#123;</div><div class="line">       System.out.println(String.format(<span class="string">"老板欠薪跑路，证据如下：%s"</span>,proof));</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span> </span>&#123;</div><div class="line">       System.out.println(String.format(<span class="string">"铁证如山，%s还Frank血汗钱"</span>,<span class="string">"马旭"</span>));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义拦截器，在调用目标方法时，CGLib会回调MethodInterceptor接口方法拦截，来实现你自己的代理逻辑，类似于JDK中的InvocationHandler接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cgLibDynProxyLawyer</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] params, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"submit"</span>))</div><div class="line">            System.out.println(<span class="string">"案件提交成功,证据如下："</span>+ Arrays.asList(params));</div><div class="line">        Object result = methodProxy.invokeSuper(o, params);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">定义动态代理工厂，生成动态代理(该步骤可以省略，直接客户端中生成代理)</div><div class="line">```java</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getGcLibDynProxy</span><span class="params">(Object target)</span></span>&#123;</div><div class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();</div><div class="line">        enhancer.setSuperclass(target.getClass());</div><div class="line">        enhancer.setCallback(<span class="keyword">new</span> cgLibDynProxyLawyer());</div><div class="line">        Object targetProxy= enhancer.create();</div><div class="line">        <span class="keyword">return</span> targetProxy;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">使用</div><div class="line">```<span class="function">java</span></div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> &#123;</div><div class="line">        Frank cProxy= (Frank) ProxyFactory.getGcLibDynProxy(<span class="keyword">new</span> Frank());</div><div class="line">        cProxy.submit(<span class="string">"工资流水在此"</span>);</div><div class="line">        cProxy.defend();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>分为静态代理 &amp; 动态代理：<br>静态代理：代理类在程序运行前已经存在的代理方式<br>动态代理：代理类在程序运行前不存在、运行时由程序动态生成的代理方式</p>
<h2 id="原型模型（Prototype-Pattern）"><a href="#原型模型（Prototype-Pattern）" class="headerlink" title="原型模型（Prototype Pattern）"></a>原型模型（Prototype Pattern）</h2><p> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节。<br> 所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆；能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常<br> clone不会执行构造函数，而且对于有成员对象是一个新的类时，只会直接引用而不是复制，这是一种浅拷贝，我们要自己处理，对于引用型的字段也采用拷贝方式<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public class CloneDemo implements Cloneable &#123;</div><div class="line">    String name;</div><div class="line">    String age;</div><div class="line"></div><div class="line">    public CloneDemo(String name, String age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected CloneDemo clone() &#123;</div><div class="line">        CloneDemo object = null;</div><div class="line">        try &#123;</div><div class="line">            object = (CloneDemo) super.clone();</div><div class="line">            object.age = age;</div><div class="line">            object.name = name;</div><div class="line">        &#125; catch (CloneNotSupportedException exception) &#123;</div><div class="line">            System.err.println("Not support cloneable");</div><div class="line">        &#125;</div><div class="line">        return object;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">## 建造者模式  </div><div class="line">将一个复杂对象的构建与他的表示分离，使得同样的构建方式可以创建不同的表示；主要用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建面临着复杂的变化</div><div class="line">使用场景：  </div><div class="line">1. 相同的方法，不同的执行顺序，产生不同的事件结果</div><div class="line">2. 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时</div><div class="line">3. 产品类非常复杂，或者产品类中的调用顺序不同产生不同的作用，</div><div class="line">4. 当初始化一个对象特别复杂，如参数特别多，且很多参数都有默认值时  </div><div class="line"></div><div class="line">首先构建一个抽象的产品类</div><div class="line">```java</div><div class="line">public abstract class Computer &#123;</div><div class="line">    public String mBoard;</div><div class="line">    public String display;</div><div class="line">    public String OS;</div><div class="line"></div><div class="line">    public Computer() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setBoard(String board) &#123;</div><div class="line">        mBoard = board;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setDisplay(String display) &#123;</div><div class="line">        this.display = display;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract void setOS();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return "mBoard:" + mBoard + "display:" + display + "OS:" + OS;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">其实构建需要创建的实际产品类型；继承自上面的产品类</div><div class="line">```java</div><div class="line">public class MacOs extends Computer &#123;</div><div class="line">    public MacOs() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setOS() &#123;</div><div class="line">        OS = "Mac Os";</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构建一个抽象的builder类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">create</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构建实际参与构建的builder类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacBookBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    Computer mComputer = <span class="keyword">new</span> MacOs();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span> </span>&#123;</div><div class="line">        mComputer.setBoard(board);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span> </span>&#123;</div><div class="line">        mComputer.setDisplay(display);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span> </span>&#123;</div><div class="line">        mComputer.setOS();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mComputer;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了防止产品构建的过程有所遗漏，我们可以创建一个组装类，用于创建产品<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line">    Builder mBuilder = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">        mBuilder = builder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contruct</span><span class="params">(String board, String display)</span> </span>&#123;</div><div class="line">        mBuilder.buildBoard(board);</div><div class="line">        mBuilder.buildDisplay(display);</div><div class="line">        mBuilder.buildOS();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Builder builder = <span class="keyword">new</span> MacBookBuilder();</div><div class="line">        Director director = <span class="keyword">new</span> Director(builder);</div><div class="line">        director.contruct(<span class="string">"11"</span>, <span class="string">"22"</span>);</div><div class="line">        System.out.println(builder.create().toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实际开发中，director对象通常会被省略，而是直接使用一个builder对象进行组装，通常这个组装为链式调用，即每个set方法都会返回其自身。即<br><figure class="highlight plain"><figcaption><span>MacBookBuilder().buildBoard("").buildOS().create;```  </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 外观模式</div><div class="line">要求一个子系统的外部与其内部 通信必须通过一个统一的对象进行，门面模式提供一个更高层次的接口，使得子系统更易于使用。一般现在三方的SDK都会使用外观模式，这样降低了用户的使用成本，也对用户屏蔽了很多实现细节</div><div class="line">首先我们要创建若干个子系统</div><div class="line">```java</div><div class="line">public interface SystemA &#123;</div><div class="line">    public void doA();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建他的实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemAImp</span> <span class="keyword">implements</span> <span class="title">SystemA</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doA</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"A"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们通过创建一个外观类，这是系统对外的统一接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facede</span> </span>&#123;</div><div class="line">    SystemA mSystemA = <span class="keyword">new</span> SystemAImp();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThing</span><span class="params">()</span> </span>&#123;</div><div class="line">        mSystemA.doA();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后客户端调用方法时，就通过这个外观类来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        Facede facede = new Facede();</div><div class="line">        facede.doThing();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>外观模式就是统一接口封装，将子系统的逻辑交互隐藏起来，为用户提供一个高层次的接口。使得系统更加易用，同时也对外隐藏了具体的实现，即使子系统发送变化，用户也不会感知到<br><strong>Android中的实现 Context</strong><br><img src="https://note.youdao.com/yws/api/personal/file/2B3FCE2310D94CC1B62231B164F694D1?method=download&amp;shareKey=7d9246b22ee018b25d84da01c16de2c8" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;四大原则&quot;&gt;&lt;a href=&quot;#四大原则&quot; class=&quot;headerlink&quot; title=&quot;四大原则&quot;&gt;&lt;/a&gt;四大原则&lt;/h2&gt;&lt;h3 id=&quot;单一职责原则&quot;&gt;&lt;a href=&quot;#单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;单一职责原
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>如何判断RecycleView是否到达底部</title>
    <link href="http://yoursite.com/2018/09/02/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADRecycleView%E6%98%AF%E5%90%A6%E5%88%B0%E8%BE%BE%E5%BA%95%E9%83%A8/"/>
    <id>http://yoursite.com/2018/09/02/如何判断RecycleView是否到达底部/</id>
    <published>2018-09-01T16:00:00.000Z</published>
    <updated>2020-02-28T03:36:50.182Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>lastVisibleItemPosition == totalItemCount - 1判断<br>该方法通过判断屏幕最后一个可见的item是整个recycleview的最后一个item<br>缺陷：当页面只有一个item，而该item的高度大于整个屏幕时，判断会有误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static boolean isVisBottom(RecyclerView recyclerView)&#123;  </div><div class="line">  LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();  </div><div class="line">  //屏幕中最后一个可见子项的position</div><div class="line">  int lastVisibleItemPosition = layoutManager.findLastVisibleItemPosition();  </div><div class="line">  //当前屏幕所看到的子项个数</div><div class="line">  int visibleItemCount = layoutManager.getChildCount();  </div><div class="line">  //当前RecyclerView的所有子项个数</div><div class="line">  int totalItemCount = layoutManager.getItemCount();  </div><div class="line">  //RecyclerView的滑动状态</div><div class="line">  int state = recyclerView.getScrollState();  </div><div class="line">  if(visibleItemCount &gt; 0 &amp;&amp; lastVisibleItemPosition == totalItemCount - 1 &amp;&amp; state == recyclerView.SCROLL_STATE_IDLE)&#123;   </div><div class="line">     return true; </div><div class="line">  &#125;else &#123;   </div><div class="line">     return false;  </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>computeVerticalScrollRange()等三个方法判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static boolean isSlideToBottom(RecyclerView recyclerView) &#123;    </div><div class="line">   if (recyclerView == null) return false; </div><div class="line">   if (recyclerView.computeVerticalScrollExtent() + recyclerView.computeVerticalScrollOffset() </div><div class="line">        &gt;= recyclerView.computeVerticalScrollRange())   </div><div class="line">     return true;  </div><div class="line">   return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>computeVerticalScrollExtent()是当前屏幕显示的区域高度，computeVerticalScrollOffset() 是当前屏幕之前滑过的距离，而computeVerticalScrollRange()是整个View控件的高度，<br><img src="https://note.youdao.com/yws/api/personal/file/8A20409B68BD4D4FB8C622AB7FD7DF5E?method=download&amp;shareKey=3405f315c85a07522cdca1f84e484882" alt="image"></p>
<ol>
<li>canScrollVertically(1)判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RecyclerView.canScrollVertically(1)的值表示是否能向上滚动，false表示已经滚动到底部</div><div class="line">RecyclerView.canScrollVertically(-1)的值表示是否能向下滚动，false表示已经滚动到顶部</div></pre></td></tr></table></figure>
</li>
</ol>
<p>该方法内部实现原理实际与方法2一致</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;lastVisibleItemPosition == totalItemCount - 1判断&lt;br&gt;该方法通过判断屏幕最后一个可见的item是整个recycleview的最后一个item&lt;br&gt;缺陷：当页面只有一个item，而该item的高度大于整个屏幕
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android与weex交互</title>
    <link href="http://yoursite.com/2018/08/27/Android%20%E4%B8%8EWeex%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2018/08/27/Android 与Weex交互/</id>
    <published>2018-08-26T16:00:00.000Z</published>
    <updated>2020-02-28T03:13:14.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="weex-初始化配置"><a href="#weex-初始化配置" class="headerlink" title="weex 初始化配置"></a>weex 初始化配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Application application, InitConfig config)</span></span></div></pre></td></tr></table></figure>
<p>weex主要通过InitConfig进行配置，由于weex主要的作用是用于渲染界面，所以除了渲染以外的事情，需要我们自己配置，通过setImgAdapter来设置自定义的图片加载器，通过setHttpAdapter来自定义网络请求方式;weex为我们实现了默认的网络请求适配器DefaultWXHttpAdapter，当发现我们在网络请求时，并没有定义网络适配器就会使用默认的DefaultWXHttpAdapter来请求网络,图片加载是需要自己去配置的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">if</span> (TextUtils.equals(sCurrentIp, DEFAULT_IP)) &#123;</div><div class="line">    renderPage(WXFileUtils.loadAsset(<span class="string">"landing.weex.js"</span>,</div><div class="line">    getApplicationContext()), getIndexUrl());</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    renderPageByURL(getIndexUrl());</div><div class="line">            </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>weex有两种渲染方式，一种是通过读取本地被编译后的js文件进行加载，另一种是直接读取网络js文件进行渲染加载。因此我们可以通过这个功能进行weex热更新。可以把所有的js文件放在服务器，或者通过下载服务器js文件后在本地进行加载</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;weex-初始化配置&quot;&gt;&lt;a href=&quot;#weex-初始化配置&quot; class=&quot;headerlink&quot; title=&quot;weex 初始化配置&quot;&gt;&lt;/a&gt;weex 初始化配置&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="weex" scheme="http://yoursite.com/categories/Android/weex/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://yoursite.com/2018/07/12/HashMap/"/>
    <id>http://yoursite.com/2018/07/12/HashMap/</id>
    <published>2018-07-11T16:00:00.000Z</published>
    <updated>2020-02-28T03:05:50.696Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>HashMap有一个叫做Entry的内部类，它用来存储key-value对。</li>
<li>上面的Entry对象是存储在一个叫做table的Entry数组中。</li>
<li>table的索引在逻辑上叫做“桶”(bucket)，它存储了链表的第一个元素。</li>
<li>key的hashcode()方法用来找到Entry对象所在的桶。</li>
<li>如果两个key有相同的hash值，他们会被放在table数组的同一个桶里面。</li>
<li>key的equals()方法用来确保key的唯一性。</li>
<li>value对象的equals()和hashcode()方法根本一点用也没有。</li>
<li>HashMap的put原理：首先判断有没有table的数组，table数组中存的是Entry对象<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Entry next;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">        ...<span class="comment">//More code goes here</span></div><div class="line">&#125;   `</div></pre></td></tr></table></figure>
</li>
</ul>
<p>没有的话，创建一个指定容量的数组，默认容量为16，然后会对key进行hash()操作，之后再根据容量以及key的hash值进行indexof操作，实际该操作就是对数组长度-1以及key的hash值进行&amp;运算，算出最后该entry在数组中的索引，然后根据索引找到该对象，这个对象是一个链表组成，我们遍历这个链表，如果为这个链表为null，就直接插入，如果有和key的equal方法比较，相同的值，就直接替换value，否则将之前链表的元素后移，新加入的放在第一个位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// HashMap允许存放null键和null值。</span></div><div class="line">    <span class="comment">// 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。  </span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">    <span class="comment">// 根据key的keyCode重新计算hash值。</span></div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</div><div class="line">    <span class="comment">// 搜索指定hash值在对应table中的索引。</span></div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="comment">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果i索引处的Entry为null，表明此处还没有Entry。</span></div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 将key、value添加到i索引处。</span></div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>hashmap的读取：<br>首先根据key找到该entry在数组中的索引，然后遍历该位置的链表，找到key的equal方法完全相同的value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">        e != <span class="keyword">null</span>;</div><div class="line">        e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </div><div class="line">            <span class="keyword">return</span> e.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要注意的是，有人觉得e.hash==hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;HashMap有一个叫做Entry的内部类，它用来存储key-value对。&lt;/li&gt;
&lt;li&gt;上面的Entry对象是存储在一个叫做table的Entry数组中。&lt;/li&gt;
&lt;li&gt;table的索引在逻辑上叫做“桶”(bucket)，它存储了链表的第一个元素。&lt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>读书笔记</title>
    <link href="http://yoursite.com/2018/06/02/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/02/读书笔记/</id>
    <published>2018-06-01T16:00:00.000Z</published>
    <updated>2020-02-28T03:07:58.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><ul>
<li>onCreate:Activity正在被创建</li>
<li>onRestart:Activity正在被重新启动</li>
<li>onStart:Activity正在被启动，其实可见但是还未出现在前台，不能进行交互</li>
<li>onResume:Activity可见 并在前台开始活动</li>
<li>onPause：Activity正在被停止，此时不可以进行交互 ，此时可以停止动画或者是其他正在运行的操作，提交没有保存的改变</li>
<li>onStop:Activity不再可见</li>
<li>onDestroy:Activity被销毁，可以释放资源</li>
</ul>
<p>针对新启动一个Activity ，会先调用旧Activity的onPause，然后 新Activity再启动，因此尽量不要再onPause中做耗时操作<br>当Activity异常终止时，会在onStop之前调用onSaveInstanceState用于保存Activity的状态，当Activity被重新创建后，会在onStart后调用onRestoreInstanceState,将刚刚方法中保存的bundle对象传递给onRestoreInstanceState以及onCreate</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul>
<li>Intent来传递数据，使用bundle</li>
<li>共享文件和 sharedpreferences（不建议）</li>
<li>基于Binder的Messager（底层实现是AIDL）</li>
<li>AIDL</li>
<li>Socket  </li>
<li>ContentProvider</li>
</ul>
<p>在一个应用中开启多进程只有一个方法，就是在AndroidMenifest中指定android:procee属性，进程名以“：”开头的进程属于当前应用的私有进程，其他应用组件不可以和他跑在同一个进程中，而进程名不以“：”开头的进程属于全局进程，其他应用通过shareuid方式可以和他跑在同一进程中<br>多进程会造成以下问题</p>
<ol>
<li>静态成员和单例模式完全失效：每个进程中会拥有一份新的成员</li>
<li>线程同步机制完全失效</li>
<li>sharedpreferences的可靠性下降： sharedpreferences底层是通过读写xml实现的，并发写可能会出问题</li>
<li>Application会多次创建：系统在创建新的进程同时会分配新的虚拟机，就相当于重新启动了一遍应用，所以会有多个Application  </li>
</ol>
<p><strong>当进行多进程通信时，当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以当一个远程方法很耗时时，我们不能在UI线程中进行 远程请求，而由于服务端的方法本身就运行在服务端的Binder线程池中，所以服务端方法本身就可以执行大量耗时操作，这时切记不要在服务端方法中开启线程去进行异步任务</strong>   </p>
<p>AIDL基本流程：</p>
<ol>
<li>创建一个Service和一个AIDL接口</li>
<li>创建一个类继承自AIDL接口中的Stub类并实现Stub中的抽象方法</li>
<li>在Service的onBind方法中返回2中的对象</li>
<li>客户端绑定该服务端Service，建立连接，返回2中的对象，通过2中的对象就可以访问远程服务端的方法</li>
</ol>
<p>疑问：当在客户端进行Service绑定时，返回的IBinder对象实际和声明的AIDL的Stub类对象是相同类型，在asInterface方法中为什么不能强转，而是要区分是否在同一进程呢</p>
<p>原因：观察asInterface方法会发现，当客户端和服务端在同一进程时，会直接进行强转，但是两者位于不同进程时，方法调用需要走onTransact方法，这是因为不同进程时，需要将数据进行序列化与反序列化操作</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景   </th>
</tr>
</thead>
<tbody>
<tr>
<td>Bundle</td>
<td>简单易用</td>
<td>只能传输Bundle支持的数据类型</td>
<td>四大组件间的进程间通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发场景，并且无法做到进程间的即时通信</td>
<td>无并发访问情形，交换简单的数据实时性不高的场景</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大，支持一对多并发通信，支持实时通信</td>
<td>使用稍复杂，需要处理好线程同步</td>
<td>一对多通信且有RPC需求</td>
</tr>
<tr>
<td>Messenger</td>
<td>功能一般，只是一对多串行通信，支持实时通信</td>
<td>不能很好处理高并发情形，不支持RPC，数据通过Message进行传输，因此只能传输Bundle支持的数据类型</td>
<td>低并发的一对多即时通信，无RPC需求，或者无须要返回结果的RPC需求</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法扩展其他操作</td>
<td>可以理解为受约束的AIDL，主要提供数据源的CRUD操作</td>
<td>一对多的进程间的数据共享</td>
</tr>
<tr>
<td>Socket</td>
<td>功能强大，可以通过网络传输字节流，支持一对多并发实时通信</td>
<td>实现细节稍微繁琐，不支持直接的RPC</td>
<td>网络数据交换</td>
</tr>
</tbody>
</table>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>View在平移过程中，top和left表示的是原始左上角的位置信息，其值并不会改变，发生改变的是x、y、translationX和translationY(左上角相对于父容器的偏移量)</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用   </th>
</tr>
</thead>
<tbody>
<tr>
<td>getX/getY</td>
<td>当前View左上角的x和y坐标 </td>
</tr>
<tr>
<td>getRawX/getRawY</td>
<td>相对于手机屏幕左上角的x和y坐标 </td>
</tr>
</tbody>
</table>
<p>TouchSlop是系统所能识别出的滑动的最小距离，可以通过该参数判断是否在进行滑动操作，获取:ViewConfiguration.get(getContext()).getScaledTouchSlop()</p>
<h3 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">pubic void smoothScrollTo()&#123;</div><div class="line">    Scroller scroller = new Scroller(context);</div><div class="line">    scroller.startScroll(0, 0, 100, 100, 1000);</div><div class="line">    invalidate();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void computeScroll() &#123;</div><div class="line">    if (scroller.computeScrollOffset()) &#123;</div><div class="line">        scrollTo(scroller.getCurrX(), scroller.getCurrY());</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察Scroller中的startScroll方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123;</div><div class="line">     mMode = SCROLL_MODE;</div><div class="line">     mFinished = false;</div><div class="line">     mDuration = duration;</div><div class="line">     mStartTime = AnimationUtils.currentAnimationTimeMillis();</div><div class="line">     mStartX = startX;</div><div class="line">     mStartY = startY;</div><div class="line">     mFinalX = startX + dx;</div><div class="line">     mFinalY = startY + dy;</div><div class="line">     mDeltaX = dx;</div><div class="line">     mDeltaY = dy;</div><div class="line">     mDurationReciprocal = 1.0f / (float) mDuration;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>实际startScroll()方法并未对View进行任何滑动处理，只是保存了一些相应滑动需要的值，真正进行滑动处理的是invalidate()方法，调用该方法后会使得页面进行重绘，而当页面进行重绘时，会在draw方法中调用computeScroll()方法，而在该方法中，会向Scroller去获取当前的scrollX和scrollY，每一次页面重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔Scroller就可以得到View当前的滑动位置;然后通过scrollTo()方法实现滑动，接着又调用postInvalidate()方法进行重绘，然后反复上述过程。</p>
<h3 id="View事件分发"><a href="#View事件分发" class="headerlink" title="View事件分发"></a>View事件分发</h3><p>针对ViewGroup的dispatchOnTouchEvent(MotionEvent ev)代码进行分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">       // Check for interception.</div><div class="line">        final boolean intercepted;</div><div class="line">        if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                || mFirstTouchTarget != null) &#123;</div><div class="line">            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">            if (!disallowIntercept) &#123;</div><div class="line">                intercepted = onInterceptTouchEvent(ev);</div><div class="line">                ev.setAction(action); // restore action in case it was changed</div><div class="line">            &#125; else &#123;</div><div class="line">                intercepted = false;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            // There are no touch targets and this action is not an initial down</div><div class="line">            // so this view group continues to intercept touches.</div><div class="line">            intercepted = true;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mFirstTouchTarget这个值意味着当事件由ViewGroup的子元素成功处理时，mFirstTouchTarget 将被赋值并指向子元素，即当ViewGroup不拦截事件并将事件交由子元素处理时mFirstTouchTarget ！=null。这个条件 if (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null) 为false时，将导致viewGroup的onInterceptTouchEvent不会再被调用，并且同一序列中的其他事件都将会默认交给它处理<br><strong>当一个view决定拦截一个事件后，那么系统会把同一个事件序列内的其他方法都直接交给它来处理，因此就不再调用这个view的onInterceptTouchEvent去询问它是否要拦截了;但是当某个事件的onTouchEvent()方法返回false后，这个view不再接受这个事件的其他事件</strong><br>FLAG_DISALLOW_INTERCEPT这个标记位是通过requestDisallowInterceptTouchEvent方法来设置，一般用于子view中。FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件。因为viewGroup在分发事件时，如果是ACTION_DOWN就会重置FLAG_DISALLOW_INTERCEPT标记位，将导致子view中设置的该标记位无效，因此在ACTION_DOWN事件时，ViewGroup会调用自己的onInterceptTouchEvent方法来询问是否拦截事件<br><strong>事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子view，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但ACTION_DOWN事件除外</strong><br>View的dispatchTouchEvent方法</p>
<pre><code class="Android">@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
     if (onFilterTouchEventForSecurity(event)) {
        if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {
            result = true;
        }
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }

  ...
    return result;
}
</code></pre>
<p><strong>View对点击事件处理时，首先会判断有没有设置mOnTouchListener，如果设置了，就判断onTouch方法是否返回true，true的话onTouchEvent就不会被调用</strong><br><img src="https://note.youdao.com/yws/api/personal/file/93827FE41AF141418CAC040ECC407DA0?method=download&amp;shareKey=8c7f988ffb46c11b1245936eab20c62d" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/9AABAAC14EB4408B86E060075E344E9A?method=download&amp;shareKey=dff13c98bbec9f1943f73ab7053657aa" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/53A522B5090644F0A433D8285308C0D1?method=download&amp;shareKey=88bd9acb68c46eb435efdc0efd5ab341" alt="image"></p>
<p><strong>decorview内部包含一个LinearLayout由标题栏和内容组成，内容就是contentView，他其实是一个FlameLayout</strong></p>
<h3 id="view测量"><a href="#view测量" class="headerlink" title="view测量"></a>view测量</h3><p>对于顶级View（DecorView）,其MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同确定；对于普通View，其MeasureSpec有其父容器的MeasureSpec和自身的LayoutParams来共同决定。</p>
<table>
<thead>
<tr>
<th>childLayoutParams \parentSpecMode</th>
<th>EXACTLY</th>
<th>AT_MOST</th>
<th>UNSPECIFIED  </th>
</tr>
</thead>
<tbody>
<tr>
<td>dp/px</td>
<td>EXACTLY childSize</td>
<td>EXACTLY childSize</td>
<td>EXACTLY childSize </td>
</tr>
<tr>
<td>match_parent</td>
<td>EXACTLY parentSize</td>
<td>AT_MOST parentSize</td>
<td>UNSPECIFIED 0 </td>
</tr>
<tr>
<td>wrap_content</td>
<td>AT_MOST parentSize</td>
<td>AT_MOST parentSize</td>
<td>UNSPECIFIED 0 </td>
</tr>
</tbody>
</table>
<h3 id="Draw流程"><a href="#Draw流程" class="headerlink" title="Draw流程"></a>Draw流程</h3><ol>
<li>绘制背景（background.draw(canvas)）</li>
<li>绘制自己（onDraw）</li>
<li>绘制children（dispatchDraw）</li>
<li>绘制装饰（onDrawScrollBars）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Activity的生命周期&quot;&gt;&lt;a href=&quot;#Activity的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Activity的生命周期&quot;&gt;&lt;/a&gt;Activity的生命周期&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;onCreate:Activity正在被
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
</feed>
