<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我要好好学习</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-20T08:17:51.539Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义View</title>
    <link href="http://yoursite.com/2018/01/16/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <id>http://yoursite.com/2018/01/16/自定义View/</id>
    <published>2018-01-16T02:59:40.554Z</published>
    <updated>2017-06-20T08:17:51.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义view"><a href="#自定义view" class="headerlink" title="自定义view"></a>自定义view</h1><ul>
<li>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)  进行测量<br>int widthMode = MeasureSpec.getMode(widthMeasureSpec);<br>int widthSize = MeasureSpec.getSize(widthMeasureSpec); </li>
<li>onFinishInflate():从xml加载组件后回调</li>
<li>onSizeChanged():组件大小改变时回调</li>
<li>onLayout():确定显示的位置</li>
<li>onTouchEvent():监听到触摸事件时的回调</li>
</ul>
<h2 id="三种实现自定义控件的方法"><a href="#三种实现自定义控件的方法" class="headerlink" title="三种实现自定义控件的方法"></a>三种实现自定义控件的方法</h2><ol>
<li>对现有控件进行拓展</li>
<li>通过组合来实现新的控件</li>
<li>重写view来实现全新的控件</li>
</ol>
<h2 id="测量模式"><a href="#测量模式" class="headerlink" title="测量模式"></a>测量模式</h2><ol>
<li>UNSPECIFIED    父容器没有对当前View有任何限制，当前View可以任意取尺寸 </li>
<li>EXACTLY    当前的尺寸就是当前View应该取的尺寸   match_parent以及固定尺寸</li>
<li>AT_MOST    当前尺寸是当前View能取的最大尺寸  wrap_content<br>new Canvas(bitmap)canvas上的所有绘制都是基于bitmap上的</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自定义view&quot;&gt;&lt;a href=&quot;#自定义view&quot; class=&quot;headerlink&quot; title=&quot;自定义view&quot;&gt;&lt;/a&gt;自定义view&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;protected void onMeasure(int widthMeasureSpe
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用说明</title>
    <link href="http://yoursite.com/2018/01/16/hello-world/"/>
    <id>http://yoursite.com/2018/01/16/hello-world/</id>
    <published>2018-01-16T02:59:40.553Z</published>
    <updated>2017-06-19T09:34:29.088Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Rxjava2分析</title>
    <link href="http://yoursite.com/2018/01/12/RxJava2/"/>
    <id>http://yoursite.com/2018/01/12/RxJava2/</id>
    <published>2018-01-11T16:00:00.000Z</published>
    <updated>2018-01-16T07:01:17.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rxjava的subcribe"><a href="#Rxjava的subcribe" class="headerlink" title="Rxjava的subcribe()"></a>Rxjava的subcribe()</h2><p>首先我们创建一个flowable<br>使用 Flowable.create() 我们获取了一个FlowableCreate对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@CheckReturnValue</div><div class="line">@BackpressureSupport(BackpressureKind.SPECIAL)</div><div class="line">@SchedulerSupport(SchedulerSupport.NONE)</div><div class="line">public static &lt;T&gt; Flowable&lt;T&gt; create(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy mode) &#123;</div><div class="line">    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</div><div class="line">    ObjectHelper.requireNonNull(mode, &quot;mode is null&quot;);</div><div class="line">    return RxJavaPlugins.onAssembly(new FlowableCreate&lt;T&gt;(source, mode));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用.subscribe()方法 发现最终都是调用下面的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@BackpressureSupport(BackpressureKind.SPECIAL)</div><div class="line">  @SchedulerSupport(SchedulerSupport.NONE)</div><div class="line">  @Beta</div><div class="line">  public final void subscribe(FlowableSubscriber&lt;? super T&gt; s) &#123;</div><div class="line">      ObjectHelper.requireNonNull(s, &quot;s is null&quot;);</div><div class="line">      try &#123;</div><div class="line">          /**该方法是对observer进行加工，</div><div class="line">          之后可以调用RxJavaPlugins的方法对observer的响应进行修改</div><div class="line">         **/</div><div class="line">          Subscriber&lt;? super T&gt; z = RxJavaPlugins.onSubscribe(this, s);</div><div class="line"></div><div class="line">          ObjectHelper.requireNonNull(z, &quot;Plugin returned null Subscriber&quot;);</div><div class="line">          /**</div><div class="line">          最重要的绑定操作实现在这个方法中，</div><div class="line">          Flowable里是一个抽象方法</div><div class="line">          我们需要到具体的 Flowable的实现类中查看</div><div class="line">         **/</div><div class="line">          subscribeActual(z);</div><div class="line">      &#125; catch (NullPointerException e) &#123; // NOPMD</div><div class="line">          throw e;</div><div class="line">      &#125; catch (Throwable e) &#123;</div><div class="line">          Exceptions.throwIfFatal(e);</div><div class="line">          // can&apos;t call onError because no way to know if a Subscription has been set or not</div><div class="line">          // can&apos;t call onSubscribe because the call might have set a Subscription already</div><div class="line">          RxJavaPlugins.onError(e);</div><div class="line"></div><div class="line">          NullPointerException npe = new NullPointerException(&quot;Actually not, but can&apos;t throw other exceptions due to RS&quot;);</div><div class="line">          npe.initCause(e);</div><div class="line">          throw npe;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>我们来查看FlowableCreate里的该方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public void subscribeActual(Subscriber&lt;? super T&gt; t) &#123;</div><div class="line">       BaseEmitter&lt;T&gt; emitter;</div><div class="line">       //该操作是针对不同情况背压我们使用不同的发射器</div><div class="line">       switch (backpressure) &#123;</div><div class="line">       case MISSING: &#123;</div><div class="line">       /**没有背压操作的正常的处理此策略表示，通过Create方法创建的Flowable没有指定背压策略，不会对通过OnNext发射的数据做缓存或丢弃处理，需要下游通过背压操作符（onBackpressureBuffer()/onBackpressureDrop()/onBackpressureLatest()）指定背压策略。</div><div class="line">       **/</div><div class="line"></div><div class="line">           emitter = new MissingEmitter&lt;T&gt;(t);</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       case ERROR: &#123;</div><div class="line">       //抛出MissingBackpressureException异常</div><div class="line">           emitter = new ErrorAsyncEmitter&lt;T&gt;(t);</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       case DROP: &#123;</div><div class="line">       //Drop就是直接把存不下的事件丢弃</div><div class="line">           emitter = new DropAsyncEmitter&lt;T&gt;(t);</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       case LATEST: &#123;</div><div class="line">       //只保留最新的事件</div><div class="line">           emitter = new LatestAsyncEmitter&lt;T&gt;(t);</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       default: &#123;</div><div class="line">       //增大上流缓冲数据的大小</div><div class="line">           emitter = new BufferAsyncEmitter&lt;T&gt;(t, bufferSize());</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       t.onSubscribe(emitter);</div><div class="line">       try &#123;</div><div class="line">    </div><div class="line">           source.subscribe(emitter);</div><div class="line">       &#125; catch (Throwable ex) &#123;</div><div class="line">           Exceptions.throwIfFatal(ex);</div><div class="line">           emitter.onError(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>主要我们查看  t.onSubscribe(emitter);  source.subscribe(emitter);两个方法<br>首先Subscriber中的onSubscribe方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * Invoked after calling &#123;@link Publisher#subscribe(Subscriber)&#125;.</div><div class="line">   * &lt;p&gt;</div><div class="line">   * No data will start flowing until &#123;@link Subscription#request(long)&#125; is invoked.</div><div class="line">   * &lt;p&gt;</div><div class="line">   * It is the responsibility of this &#123;@link Subscriber&#125; instance to call &#123;@link Subscription#request(long)&#125; whenever more data is wanted.</div><div class="line">   * &lt;p&gt;</div><div class="line">   * The &#123;@link Publisher&#125; will send notifications only in response to &#123;@link Subscription#request(long)&#125;.</div><div class="line">   * </div><div class="line">   * @param s</div><div class="line">   *            &#123;@link Subscription&#125; that allows requesting data via &#123;@link Subscription#request(long)&#125;</div><div class="line">   */</div><div class="line">  public void onSubscribe(Subscription s);</div></pre></td></tr></table></figure></p>
<p>根据注释我们可以了解 在调用onSubscribe后数据请求才真正的开始，所以当我们使用rxjava的时候 <strong>只有进行订阅后事件请求才开始</strong><br>然后我们看FlowableOnSubscribe的subscribe方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A functional interface that has a &#123;@code subscribe()&#125; method that receives</div><div class="line"> * an instance of a &#123;@link FlowableEmitter&#125; instance that allows pushing</div><div class="line"> * events in a backpressure-safe and cancellation-safe manner.</div><div class="line"> *</div><div class="line"> * @param &lt;T&gt; the value type pushed</div><div class="line"> */</div><div class="line">public interface FlowableOnSubscribe&lt;T&gt; &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Called for each Subscriber that subscribes.</div><div class="line">     * @param e the safe emitter instance, never null</div><div class="line">     * @throws Exception on error</div><div class="line">     */</div><div class="line">    void subscribe(@NonNull FlowableEmitter&lt;T&gt; e) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们发现这是一个接口  去查看实现的位置<br>该接口的实现是在Flowable的初始化的时候，也就是我们调用flowable的create方法的时候传入的发射器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@CheckReturnValue</div><div class="line"> @BackpressureSupport(BackpressureKind.SPECIAL)</div><div class="line"> @SchedulerSupport(SchedulerSupport.NONE)</div><div class="line"> public static &lt;T&gt; Flowable&lt;T&gt; create(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy mode) &#123;</div><div class="line">     ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</div><div class="line">     ObjectHelper.requireNonNull(mode, &quot;mode is null&quot;);</div><div class="line">     return RxJavaPlugins.onAssembly(new FlowableCreate&lt;T&gt;(source, mode));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>也就是去消费发射器里的方法 也就实现了观察者中的方法的调用</p>
<p>至此一个链式操作就实现了  </p>
<h2 id="Rxjava-操作符"><a href="#Rxjava-操作符" class="headerlink" title="Rxjava 操作符"></a>Rxjava 操作符</h2><ol>
<li><p>map<br>map是RxJava中最简单的一个变换操作符了,它的作用就是对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化.<br><img src="https://upload-images.jianshu.io/upload_images/1008453-2a068dc6b726568a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/580" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                emitter.onNext(1);</div><div class="line">                emitter.onNext(2);</div><div class="line">                emitter.onNext(3);</div><div class="line">            &#125;</div><div class="line">        &#125;).map(new Function&lt;Integer, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String apply(Integer integer) throws Exception &#123;</div><div class="line">                return &quot;This is result &quot; + integer;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(String s) throws Exception &#123;</div><div class="line">                Log.d(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>FlatMap<br>FlatMap将一个发送事件的上游Observable变换为多个发送事件的Observables，然后将它们发射的事件合并后放进一个单独的Observable里.<br><img src="https://upload-images.jianshu.io/upload_images/1008453-659c8c548805fdcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/580" alt=""></p>
</li>
</ol>
<p><strong>flatMap并不保证事件的顺序如果需要保证顺序则需要使用concatMap</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                emitter.onNext(1);</div><div class="line">                emitter.onNext(2);</div><div class="line">                emitter.onNext(3);</div><div class="line">            &#125;</div><div class="line">        &#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123;</div><div class="line">                final List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">                for (int i = 0; i &lt; 3; i++) &#123;</div><div class="line">                    list.add(&quot;I am value &quot; + integer);</div><div class="line">                &#125;</div><div class="line">                return Observable.fromIterable(list).delay(10,TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(String s) throws Exception &#123;</div><div class="line">                Log.d(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<ol>
<li>zip<br>Zip通过一个函数将多个Observable发送的事件结合到一起，然后发送这些组合到一起的事件. 它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。<br><img src="https://upload-images.jianshu.io/upload_images/1008453-e11e9d75b1775e4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633" alt=""></li>
</ol>
<p><strong>注意针对每个观察者都要在一个新进程里运行 ，不然会先执行第一个再执行第二个</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;         </div><div class="line">    @Override                                                                                      </div><div class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;                   </div><div class="line">        Log.d(TAG, &quot;emit 1&quot;);                                                                      </div><div class="line">        emitter.onNext(1);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, &quot;emit 2&quot;);                                                                      </div><div class="line">        emitter.onNext(2);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, &quot;emit 3&quot;);                                                                      </div><div class="line">        emitter.onNext(3);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, &quot;emit 4&quot;);                                                                      </div><div class="line">        emitter.onNext(4);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, &quot;emit complete1&quot;);                                                              </div><div class="line">        emitter.onComplete();                                                                      </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribeOn(Schedulers.io());                                                                   </div><div class="line">                                                                                                   </div><div class="line">Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;           </div><div class="line">    @Override                                                                                      </div><div class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;                    </div><div class="line">        Log.d(TAG, &quot;emit A&quot;);                                                                      </div><div class="line">        emitter.onNext(&quot;A&quot;);                                                                       </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, &quot;emit B&quot;);                                                                      </div><div class="line">        emitter.onNext(&quot;B&quot;);                                                                       </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, &quot;emit C&quot;);                                                                      </div><div class="line">        emitter.onNext(&quot;C&quot;);                                                                       </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, &quot;emit complete2&quot;);                                                              </div><div class="line">        emitter.onComplete();                                                                      </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribeOn(Schedulers.io());                                                                   </div><div class="line">                                                                                                   </div><div class="line">Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123;               </div><div class="line">    @Override                                                                                      </div><div class="line">    public String apply(Integer integer, String s) throws Exception &#123;                              </div><div class="line">        return integer + s;                                                                        </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;                    </div><div class="line">    @Override                                                                                      </div><div class="line">    public void onSubscribe(Disposable d) &#123;                                                        </div><div class="line">        Log.d(TAG, &quot;onSubscribe&quot;);                                                                 </div><div class="line">    &#125;                                                                                              </div><div class="line">                                                                                                   </div><div class="line">    @Override                                                                                      </div><div class="line">    public void onNext(String value) &#123;                                                             </div><div class="line">        Log.d(TAG, &quot;onNext: &quot; + value);                                                            </div><div class="line">    &#125;                                                                                              </div><div class="line">                                                                                                   </div><div class="line">    @Override                                                                                      </div><div class="line">    public void onError(Throwable e) &#123;                                                             </div><div class="line">        Log.d(TAG, &quot;onError&quot;);                                                                     </div><div class="line">    &#125;                                                                                              </div><div class="line">                                                                                                   </div><div class="line">    @Override                                                                                      </div><div class="line">    public void onComplete() &#123;                                                                     </div><div class="line">        Log.d(TAG, &quot;onComplete&quot;);                                                                  </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="背压"><a href="#背压" class="headerlink" title="背压"></a><a href="https://www.jianshu.com/p/9b1304435564" target="_blank" rel="external">背压</a></h2><p>这是因为Flowable在设计的时候采用了一种新的思路也就是响应式拉取的方式来更好的解决上下游流速不均衡的问题, 与我们之前所讲的控制数量和控制速度不太一样, 这种方式用通俗易懂的话来说就好比是叶问打鬼子, 我们把上游看成小日本, 把下游当作叶问, 当调用Subscription.request(1)时, 叶问就说我要打一个! 然后小日本就拿出一个鬼子给叶问, 让他打, 等叶问打死这个鬼子之后, 再次调用request(10), 叶问就又说我要打十个! 然后小日本又派出十个鬼子给叶问, 然后就在边上看热闹, 看叶问能不能打死十个鬼子, 等叶问打死十个鬼子后再继续要鬼子接着打…</p>
<p>所以我们把request当做是一种能力, 当成下游处理事件的能力, 下游能处理几个就告诉上游我要几个, 这样只要上游根据下游的处理能力来决定发送多少事件, 就不会造成一窝蜂的发出一堆事件来, 从而导致OOM. 这也就完美的解决之前我们所学到的两种方式的缺陷, 过滤事件会导致事件丢失, 减速又可能导致性能损失. 而这种方式既解决了事件丢失的问题, 又解决了速度的问题, 完美 !</p>
<p><strong>针对Flowable 由于是下游需要几个 就调用request方法取几个，所以 如果实现Subscriber的时候 在onSubscribe方法中需要调用t.request(Long.MAX_VALUE);<br>当然如果我们只使用onNext等方法可以不需要</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">   @CheckReturnValue</div><div class="line">    @BackpressureSupport(BackpressureKind.SPECIAL)</div><div class="line">    @SchedulerSupport(SchedulerSupport.NONE)</div><div class="line">    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,</div><div class="line">            Action onComplete, Consumer&lt;? super Subscription&gt; onSubscribe) &#123;</div><div class="line">        ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);</div><div class="line">        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</div><div class="line">        ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</div><div class="line">        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</div><div class="line">//在绑定的时候我们可以看到都生成了一个LambdaSubscriber观察者</div><div class="line">        LambdaSubscriber&lt;T&gt; ls = new LambdaSubscriber&lt;T&gt;(onNext, onError, onComplete, onSubscribe);</div><div class="line"></div><div class="line">        subscribe(ls);</div><div class="line"></div><div class="line">        return ls;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>根据之前的分析 在subscribeActual中实际执行了        t.onSubscribe(emitter);<br>我们回到LambdaSubscriber中看该方法实现了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override</div><div class="line">public void onSubscribe(Subscription s) &#123;</div><div class="line">    if (SubscriptionHelper.setOnce(this, s)) &#123;</div><div class="line">        try &#123;</div><div class="line">            onSubscribe.accept(this);</div><div class="line">        &#125; catch (Throwable ex) &#123;</div><div class="line">            Exceptions.throwIfFatal(ex);</div><div class="line">            s.cancel();</div><div class="line">            onError(ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们发现他执行了accept方法  然后我们回到Flowable的subscribe方法看 ，发现如果我们没有传onSubscribe系统会默认传入FlowableInternalHelper.RequestMax.INSTANCE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public enum RequestMax implements Consumer&lt;Subscription&gt; &#123;</div><div class="line">    INSTANCE;</div><div class="line">    @Override</div><div class="line">    public void accept(Subscription t) throws Exception &#123;</div><div class="line">        t.request(Long.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里实现了下游 获取数据 所以我们不需要自己去实现</p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>Flowable上游有一个缓冲池 ，当同步加载的时候，就是下游request一个，上游取一个，（当上下游工作在同一个线程中时, 这时候是一个同步的订阅关系, 也就是说上游每发送一个事件必须等到下游接收处理完了以后才能接着发送下一个事件）但是当异步请求的时候，上游自身有一个request这个request=128 意味着上游的缓冲池可以放128个数据，<br>上游按照需要把onnext方法请求放入缓冲池 ，假设我们放入1个,按理下游取出1个，那缓冲池的数据将减小一，但是事实不是这样的，当我们下游执行到96个数据的时候，缓冲池才会进行一遍清理，将没有用的数据清除，上游的request就会等于128减去缓冲池里未处理的数据。<br>而MissingBackpressureException的产生原因就是上下游数据处理速度不一致，假设上游处理的更快，我们放入了128个数据，但是下游处理的事件不到96个，那么如果再发送数据的话，缓冲池接受不了 就会抛出异常，我们设置的背压策略就是为了解决这个问题的<br>我们也可以当上游在e.requested()等于0时，暂停发射数据，便可解决背压问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Rxjava的subcribe&quot;&gt;&lt;a href=&quot;#Rxjava的subcribe&quot; class=&quot;headerlink&quot; title=&quot;Rxjava的subcribe()&quot;&gt;&lt;/a&gt;Rxjava的subcribe()&lt;/h2&gt;&lt;p&gt;首先我们创建一个flowab
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Animation 动画深度分析</title>
    <link href="http://yoursite.com/2016/02/21/%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2016/02/21/动画/</id>
    <published>2016-02-20T16:00:00.000Z</published>
    <updated>2017-06-20T08:16:48.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="View-Animation"><a href="#View-Animation" class="headerlink" title="View Animation"></a>View Animation</h2><p> 视图动画，也叫Tween（补间）动画可以在一个视图容器内执行一系列简单变换（位置、大小、旋转、透明度）。譬如，如果你有一个TextView对象，您可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。</p>
<ol>
<li>Alpha(透明度) 属性：用于控制动画的透明度</li>
<li>Rotate（旋转）属性 ：可以对视图进行旋转</li>
<li>Scale（缩放）属性：对视图进行缩放</li>
<li>Translate属性：可以对视图进行变换</li>
<li>AnimationSet继承自Animation，是上面四种的组合容器管理类，没有自己特有的属性，他的属性继承自Animation，当我们对set标签使用Animation的属性时会对该标签下的所有子控件都产生影响。</li>
<li>Interpolator（插值器）属性：类似于动画以一个什么样的速率去执行动画<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">	&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    </div><div class="line">	&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   </div><div class="line">    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;  </div><div class="line">    android:shareInterpolator=[&quot;true&quot; | &quot;false&quot;] &gt;</div><div class="line">    &lt;alpha</div><div class="line">        android:fromAlpha=&quot;float&quot;</div><div class="line">        android:toAlpha=&quot;float&quot; /&gt;</div><div class="line">    &lt;scale</div><div class="line">        android:fromXScale=&quot;float&quot;</div><div class="line">        android:toXScale=&quot;float&quot;</div><div class="line">        android:fromYScale=&quot;float&quot;</div><div class="line">        android:toYScale=&quot;float&quot;</div><div class="line">        android:pivotX=&quot;float&quot;</div><div class="line">        android:pivotY=&quot;float&quot; /&gt;</div><div class="line">    &lt;translate</div><div class="line">        android:fromXDelta=&quot;float&quot;</div><div class="line">        android:toXDelta=&quot;float&quot;</div><div class="line">        android:fromYDelta=&quot;float&quot;</div><div class="line">        android:toYDelta=&quot;float&quot; /&gt;</div><div class="line">    &lt;rotate</div><div class="line">        android:fromDegrees=&quot;float&quot;</div><div class="line">        android:toDegrees=&quot;float&quot;</div><div class="line">        android:pivotX=&quot;float&quot;</div><div class="line">        android:pivotY=&quot;float&quot; /&gt;</div><div class="line">    &lt;set&gt;</div><div class="line">        ...</div><div class="line">    &lt;/set&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<table>
<thead>
<tr>
<th>View类的常用动画操作方法</th>
<th>解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td>startAnimation(Animation animation)</td>
<td>对当前View开始设置的Animation动画</td>
</tr>
<tr>
<td>clearAnimation()</td>
<td>取消当View在执行的Animation动画</td>
</tr>
</tbody>
</table>
<p><strong>补间动画执行之后并未改变View的真实布局属性值。我们对一个Button进行操作，将他从原来的位置移动到另一位置，但是实际响应button事件的位置，还是原来的位置。</strong><br><a id="more"></a></p>
<h2 id="Drawable-Animation"><a href="#Drawable-Animation" class="headerlink" title="Drawable Animation"></a>Drawable Animation</h2><p> Drawable动画其实就是Frame动画（帧动画），它允许你实现像播放幻灯片一样的效果，这种动画的实质其实是Drawable，所以这种动画的XML定义方式文件一般放在res/drawable/目录下。加载效果的实现</p>
<ol>
<li><animation-list> 必须是根节点，包含一个或者多个item元素，包含属性如下：<ul>
<li>android:oneshot true代表只执行一次，false循环执行。</li>
</ul>
</animation-list></li>
<li>item 类似一帧的动画资源，animation-list的子项，包含属性如下：<ul>
<li>android:drawable 一个frame的Drawable资源。</li>
<li>android:duration 一个frame显示多长时间。</li>
</ul>
</li>
</ol>
<p><strong>AnimationDrawable的start()方法不能在Activity的onCreate方法中调运，因为AnimationDrawable还未完全附着到window上，所以最好的调运时机是onWindowFocusChanged()方法中。</strong></p>
<h2 id="Property-Animation"><a href="#Property-Animation" class="headerlink" title="Property Animation"></a>Property Animation</h2><p> 属性动画只对Android 3.0（API 11）以上版本的Android系统才有效，这种动画可以设置给任何Object，包括那些还没有渲染到屏幕上的对象。这种动画是可扩展的，可以让你自定义任何类型和属性的动画。<strong>实现原理就是修改控件的属性值实现的动画，改变的是对象的真实属性</strong><br>基本属性如下：</p>
<ul>
<li>Duration：动画的持续时间；</li>
<li>TimeInterpolation：定义动画变化速率的接口，所有插值器都必须实现此接口，如线性、非线性插值器；</li>
<li>TypeEvaluator：用于定义属性值计算方式的接口，有int、float、color类型，根据属性的起始、结束值和插值一起计算出当前时间的属性值；</li>
<li>Animation sets：动画集合，即可以同时对一个对象应用多个动画，这些动画可以同时播放也可以对不同动画设置不同的延迟；</li>
<li>Frame refreash delay：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响；</li>
<li>Repeat Country and behavoir：重复次数与方式，如播放3次、5次、无限循环，可以让此动画一直重复，或播放完时向反向播放；  </li>
</ul>
<h3 id="1-set属性解释："><a href="#1-set属性解释：" class="headerlink" title="1.set属性解释："></a>1.set属性解释：</h3><table>
<thead>
<tr>
<th>xml属性</th>
<th>解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td> android:ordering</td>
<td>控制子动画启动方式是先后有序的还是同时进行。sequentially:动画按照先后顺序；together(默认):动画同时启动 </td>
</tr>
</tbody>
</table>
<h3 id="2-objectAnimator属性解释："><a href="#2-objectAnimator属性解释：" class="headerlink" title="2.objectAnimator属性解释："></a>2.objectAnimator属性解释：</h3><table>
<thead>
<tr>
<th>xml属性</th>
<th>解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td>android:propertyName</td>
<td>String类型，必须要设置的节点属性，代表要执行动画的属性（通过名字引用），辟如你可以指定了一个View的”alpha” 或者 “backgroundColor” ，这个objectAnimator元素没有对外说明target属性，所以你不能在XML中设置执行这个动画，必须通过调用 loadAnimator()方法加载你的XML动画资源，然后调用setTarget()应用到具备这个属性的目标对象上（譬如TextView）。</td>
</tr>
<tr>
<td>android:valueTo</td>
<td>float、int或者color类型，必须要设置的节点属性，表明动画结束的点；如果是颜色的话，由6位十六进制的数字表示。</td>
</tr>
<tr>
<td>android:valueFrom</td>
<td>相对应valueTo，动画的起始点，如果没有指定，系统会通过属性的get方法获取，颜色也是6位十六进制的数字表示。</td>
</tr>
<tr>
<td>android:duration</td>
<td>动画的时长，int类型，以毫秒为单位，默认为300毫秒。</td>
</tr>
<tr>
<td>android:startOffset</td>
<td>动画延迟的时间，从调用start方法后开始计算，int型，毫秒为单位。</td>
</tr>
<tr>
<td>android:repeatCount</td>
<td>一个动画的重复次数，int型，”-1“表示无限循环，”1“表示动画在第一次执行完成后重复执行一次，也就是两次，默认为0，不重复执行。</td>
</tr>
<tr>
<td>android:repeatMode</td>
<td>重复模式：int型，当一个动画执行完的时候应该如何处理。该值必须是正数或者是-1，“reverse”会使得按照动画向相反的方向执行，可实现类似钟摆效果。“repeat”会使得动画每次都从头开始循环。</td>
</tr>
<tr>
<td>android:valueType</td>
<td>关键参数，如果该value是一个颜色，那么就不需要指定，因为动画框架会自动的处理颜色值。有intType和floatType（默认）两种：分别说明动画值为int和float型。</td>
</tr>
</tbody>
</table>
<h3 id="3-XML属性动画使用方法："><a href="#3-XML属性动画使用方法：" class="headerlink" title="3.XML属性动画使用方法："></a>3.XML属性动画使用方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,</div><div class="line">   R.animtor.property_animator);</div><div class="line">set.setTarget(myObject);</div><div class="line">set.start();</div></pre></td></tr></table></figure>
<h3 id="4-ValueAnimator实现动画"><a href="#4-ValueAnimator实现动画" class="headerlink" title="4.ValueAnimator实现动画"></a>4.ValueAnimator实现动画</h3><p>属性动画中的时间驱动，管理着动画时间的开始、结束属性值，相应时间属性值计算方法等。包含所有计算动画值的核心函数以及每一个动画时间节点上的信息、一个动画是否重复、是否监听更新事件等，并且还可以设置自定义的计算类型。<br><strong>ValueAnimator只是动画计算管理驱动，设置了作用目标，但没有设置属性，需要通过updateListener里设置属性才会生效。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ValueAnimator animator = ValueAnimator.ofFloat(0, mContentHeight);  //定义动画</div><div class="line">animator.setTarget(view);   //设置作用目标</div><div class="line">animator.setDuration(5000).start();</div><div class="line">animator.addUpdateListener(new AnimatorUpdateListener() &#123;</div><div class="line">   @Override</div><div class="line">   public void onAnimationUpdate(ValueAnimator animation)&#123;</div><div class="line">       float value = (float) animation.getAnimatedValue();</div><div class="line">       view.setXXX(value);  //必须通过这里设置属性值才有效</div><div class="line">       view.mXXX = value;  //不需要setXXX属性方法</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="5-ObjectAnimator实现动画"><a href="#5-ObjectAnimator实现动画" class="headerlink" title="5.ObjectAnimator实现动画"></a>5.ObjectAnimator实现动画</h3><p>继承自ValueAnimator，允许你指定要进行动画的对象以及该对象 的一个属性。不需要和ValueAnimator那样自己写动画更新的逻辑，但是ObjectAnimator有一定的限制，比如它需要目标对象的属性提供指定 的处理方法（譬如提供getXXX，setXXX方法）<br>ObjectAnimator类提供了ofInt、ofFloat、ofObject这个三个常用的方法，这些方法都是设置动画作用的元素、属性、开始、结束等任意属性值。当属性值（上面方法的参数）只设置一个时就把通过getXXX反射获取的值作为起点，设置的值作为终点；如果设置两个（参数），那么一个是开始、另一个是结束。<br><strong>ObjectAnimator的动画原理是不停的调用setXXX方法更新属性值，所有使用ObjectAnimator更新属性时的前提是Object必须声明有getXXX和setXXX方法。</strong><br>我们通常使用ObjectAnimator设置View已知的属性来生成动画，而一般View已知属性变化时都会主动触发重绘图操作，所以动画会自 动实现；但是也有特殊情况，譬如作用Object不是View，或者作用的属性没有触发重绘，或者我们在重绘时需要做自己的操作，那都可以通过如下方法手 动设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator mObjectAnimator= ObjectAnimator.ofInt(view, &quot;customerDefineAnyThingName&quot;, 0,  1).setDuration(2000);</div><div class="line">mObjectAnimator.addUpdateListener(new AnimatorUpdateListener()</div><div class="line">       &#123;</div><div class="line">           @Override</div><div class="line">           public void onAnimationUpdate(ValueAnimator animation)</div><div class="line">           &#123;</div><div class="line">               //int value = animation.getAnimatedValue();  可以获取当前属性值</div><div class="line">               //view.postInvalidate();  可以主动刷新</div><div class="line">               //view.setXXX(value);</div><div class="line">               //view.setXXX(value);</div><div class="line">               //......可以批量修改属性</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>ValueAnimator和ObjectAnimator没啥区别，实际上正是由于ValueAnimator不直接操作属性值，所以要操作对象的属性可以不需要setXXX与getXXX方法，你完全可以通过当前动画的计算去修改任何属性。</p>
<h3 id="6-AnimatorSet的使用"><a href="#6-AnimatorSet的使用" class="headerlink" title="6.AnimatorSet的使用"></a>6.AnimatorSet的使用</h3><p>动画集合，提供把多个动画组合成一个组合的机制，并可设置动画的时序关系，如同时播放、顺序播放或延迟播放<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator a1 = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1.0f, 0f);  </div><div class="line">ObjectAnimator a2 = ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0f, viewWidth);  </div><div class="line">......</div><div class="line">AnimatorSet animSet = new AnimatorSet();  </div><div class="line">animSet.setDuration(5000);  </div><div class="line">animSet.setInterpolator(new LinearInterpolator());   </div><div class="line">//animSet.playTogether(a1, a2, ...); //两个动画同时执行  </div><div class="line">animSet.play(a1).after(a2); //先后执行</div><div class="line">......//其他组合方式</div><div class="line">animSet.start();</div></pre></td></tr></table></figure></p>
<h3 id="7-Evaluators"><a href="#7-Evaluators" class="headerlink" title="7.Evaluators"></a>7.Evaluators</h3><p> Evaluators就是属性动画系统如何去计算一个属性值。它们通过Animator提供的动画的起始和结束值去计算一个动画的属性值。</p>
<p>IntEvaluator：整数属性值。</p>
<p>FloatEvaluator：浮点数属性值。</p>
<p>ArgbEvaluator：十六进制color属性值。</p>
<p>TypeEvaluator：用户自定义属性值接口，譬如对象属性值类型不是int、float、color类型，你必须实现这个接口去定义自己的数据类型。</p>
<p>如下类型float[]：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = new ValueAnimator();</div><div class="line">valueAnimator.setDuration(5000);</div><div class="line">valueAnimator.setObjectValues(new float[2]); //设置属性值类型</div><div class="line">valueAnimator.setInterpolator(new LinearInterpolator());</div><div class="line">valueAnimator.setEvaluator(new TypeEvaluator&lt;float[]&gt;()</div><div class="line">&#123;</div><div class="line">   @Override</div><div class="line">   public float[] evaluate(float fraction, float[] startValue,</div><div class="line">                           float[] endValue)</div><div class="line">   &#123;</div><div class="line">       //实现自定义规则计算的float[]类型的属性值</div><div class="line">       float[] temp = new float[2];</div><div class="line">       temp[0] = fraction * 2;</div><div class="line">       temp[1] = (float)Math.random() * 10 * fraction;</div><div class="line">       return temp;</div><div class="line">   &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">valueAnimator.start();</div><div class="line">valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener()</div><div class="line">&#123;</div><div class="line">   @Override</div><div class="line">   public void onAnimationUpdate(ValueAnimator animation)</div><div class="line">   &#123;</div><div class="line">       float[] xyPos = (float[]) animation.getAnimatedValue();</div><div class="line">       view.setHeight(xyPos[0]);   //通过属性值设置View属性动画</div><div class="line">       view.setWidth(xyPos[1]);    //通过属性值设置View属性动画</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="8-Interpolators插值器"><a href="#8-Interpolators插值器" class="headerlink" title="8.Interpolators插值器"></a>8.Interpolators插值器</h3><ul>
<li><p>AccelerateDecelerateInterolator：先加速后减速。</p>
</li>
<li><p>AccelerateInterpolator：加速。</p>
</li>
<li><p>DecelerateInterpolator：减速。</p>
</li>
<li><p>AnticipateInterpolator：先向相反方向改变一段再加速播放。</p>
</li>
<li><p>AnticipateOvershootInterpolator：先向相反方向改变，再加速播放，会超出目标值然后缓慢移动至目标值，类似于弹簧回弹。</p>
</li>
<li><p>BounceInterpolator：快到目标值时值会跳跃。</p>
</li>
<li><p>CycleIinterpolator：动画循环一定次数，值的改变为一正弦函数：Math.sin(2 <em> mCycles </em> Math.PI * input)。</p>
</li>
<li><p>LinearInterpolator：线性均匀改变。</p>
</li>
<li><p>OvershottInterpolator：最后超出目标值然后缓慢改变到目标值。</p>
</li>
<li><p>TimeInterpolator：一个允许自定义Interpolator的接口，以上都实现了该接口。  </p>
<p> 自定义插值器：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//开始很慢然后不断加速的插值器  </div><div class="line">public class AccelerateInterpolator implements Interpolator &#123;</div><div class="line">   private final float mFactor;</div><div class="line">   private final double mDoubleFactor;</div><div class="line"></div><div class="line">   public AccelerateInterpolator() &#123;</div><div class="line">       mFactor = 1.0f;</div><div class="line">       mDoubleFactor = 2.0;</div><div class="line">   &#125;</div><div class="line">   //input  0到1.0。表示动画当前点的值，0表示开头，1表示结尾。</div><div class="line">   //return  插值。值可以大于1超出目标值，也可以小于0突破低值。</div><div class="line">   @Override</div><div class="line">   public float getInterpolation(float input) &#123;</div><div class="line">       //实现核心代码块</div><div class="line">       if (mFactor == 1.0f) &#123;</div><div class="line">           return input * input;</div><div class="line">       &#125; else &#123;</div><div class="line">           return (float)Math.pow(input, mDoubleFactor);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="9-LayoutAnimator容器布局动画"><a href="#9-LayoutAnimator容器布局动画" class="headerlink" title="9.LayoutAnimator容器布局动画"></a>9.LayoutAnimator容器布局动画</h3><p>对ViewGroup中View添加时的动画功能，我们可以用LayoutTransition对 ViewGroup中的View进行动画设置显示。LayoutTransition的动画效果都是设置给ViewGroup，然后当被<strong>设置动画的 ViewGroup中添加删除View时体现出来</strong>。该类用于当前布局容器中有View添加、删除、隐藏、显示等时候定义布局容器自身的动画和View的动 画，也就是说当在一个LinerLayout中隐藏一个View的时候，我们可以自定义 整个由于LinerLayout隐藏View而改变的动画，同时还可以自定义被隐藏的View自己消失时候的动画等。</p>
<p> LayoutTransition类中主要有五种容器转换动画类型，具体如下：</p>
<ul>
<li><p>LayoutTransition.APPEARING：当View出现或者添加的时候View出现的动画。</p>
</li>
<li><p>LayoutTransition.CHANGE_APPEARING：当添加View导致布局容器改变的时候整个布局容器的动画。</p>
</li>
<li><p>LayoutTransition.DISAPPEARING：当View消失或者隐藏的时候View消失的动画。</p>
</li>
<li><p>LayoutTransition.CHANGE_DISAPPEARING：当删除或者隐藏View导致布局容器改变的时候整个布局容器的动画。</p>
</li>
<li><p>LayoutTransition.CHANGE：当不是由于View出现或消失造成对其他View位置造成改变的时候整个布局容器的动画。</p>
</li>
</ul>
<p>XML方式使用系统提供的默认LayoutTransition动画：</p>
<p>我们可以通过如下方式使用系统提供的默认ViewGroup的LayoutTransition动画：</p>
<p>android:animateLayoutChanges=”true”</p>
<p>在ViewGroup添加如上xml属性默认是没有任何动画效果的，因为前面说了，该动画针对于ViewGroup内部东西发生改变时才有效，所以当我们设置如上属性然后调运ViewGroup的addView、removeView方法时就能看见系统默认的动画效果了。</p>
<p>还有一种就是通过如下方式设置：</p>
<p>android:layoutAnimation=”@anim/customer_anim”</p>
<p>在使用LayoutTransition时，你可以自定义这几种事件类型的动画，也可以使用默认的动画，总之最终都是通过 setLayoutTransition(LayoutTransition lt)方法把这些动画以一个LayoutTransition对象设置给一个ViewGroup。</p>
<p>譬如实现如上Xml方式的默认系统LayoutTransition动画如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mTransitioner = new LayoutTransition();</div><div class="line">mViewGroup.setLayoutTransition(mTransitioner);</div></pre></td></tr></table></figure></p>
<p>自定义这几类事件的动画，分别实现他们，可以像下面这么处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mTransitioner = new LayoutTransition();</div><div class="line">......</div><div class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, 0, 1);</div><div class="line">......//设置更多动画</div><div class="line">mTransition.setAnimator(LayoutTransition.APPEARING, anim);</div><div class="line">.....//设置更多类型的动画                </div><div class="line">mViewGroup.setLayoutTransition(mTransitioner);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;View-Animation&quot;&gt;&lt;a href=&quot;#View-Animation&quot; class=&quot;headerlink&quot; title=&quot;View Animation&quot;&gt;&lt;/a&gt;View Animation&lt;/h2&gt;&lt;p&gt; 视图动画，也叫Tween（补间）动画可以在一个视图容器内执行一系列简单变换（位置、大小、旋转、透明度）。譬如，如果你有一个TextView对象，您可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Alpha(透明度) 属性：用于控制动画的透明度&lt;/li&gt;
&lt;li&gt;Rotate（旋转）属性 ：可以对视图进行旋转&lt;/li&gt;
&lt;li&gt;Scale（缩放）属性：对视图进行缩放&lt;/li&gt;
&lt;li&gt;Translate属性：可以对视图进行变换&lt;/li&gt;
&lt;li&gt;AnimationSet继承自Animation，是上面四种的组合容器管理类，没有自己特有的属性，他的属性继承自Animation，当我们对set标签使用Animation的属性时会对该标签下的所有子控件都产生影响。&lt;/li&gt;
&lt;li&gt;Interpolator（插值器）属性：类似于动画以一个什么样的速率去执行动画&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;set xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    android:interpolator=&amp;quot;@[package:]anim/interpolator_resource&amp;quot;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    android:shareInterpolator=[&amp;quot;true&amp;quot; | &amp;quot;false&amp;quot;] &amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;alpha&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromAlpha=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toAlpha=&amp;quot;float&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;scale&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromXScale=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toXScale=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromYScale=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toYScale=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:pivotX=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:pivotY=&amp;quot;float&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;translate&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromXDelta=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toXDelta=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromYDelta=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toYDelta=&amp;quot;float&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;rotate&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromDegrees=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toDegrees=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:pivotX=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:pivotY=&amp;quot;float&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;set&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;/set&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/set&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;View类的常用动画操作方法&lt;/th&gt;
&lt;th&gt;解释 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;startAnimation(Animation animation)&lt;/td&gt;
&lt;td&gt;对当前View开始设置的Animation动画&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clearAnimation()&lt;/td&gt;
&lt;td&gt;取消当View在执行的Animation动画&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;补间动画执行之后并未改变View的真实布局属性值。我们对一个Button进行操作，将他从原来的位置移动到另一位置，但是实际响应button事件的位置，还是原来的位置。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
</feed>
