<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Smile&#39;Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-19T07:24:45.224Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>翻过墙来看世界</title>
    <link href="http://yoursite.com/2018/01/19/%E7%BF%BB%E8%BF%87%E5%A2%99%E6%9D%A5%E7%9C%8B%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2018/01/19/翻过墙来看世界/</id>
    <published>2018-01-18T16:00:00.000Z</published>
    <updated>2018-01-19T07:24:45.224Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名优秀的程序员，如果不能看看外面的世界，简直是阻碍了我们进步的脚步，无意间看到一篇博文讲解自己租用服务器来翻墙，所以决定试一试。<br>对比了搬瓦工与vultr及linode三家VPS服务商，最后决定先用vultr的服务器先试一试，一般来说使用离国内越近的位置，速度也越快，东京和新加坡是比较好的选择，买了西雅图的好像也还不错，1080P没有什么问题<br>下面我们来说一说配置的过程</p>
<a id="more"></a>
<h2 id="1-购买服务器"><a href="#1-购买服务器" class="headerlink" title="1. 购买服务器"></a>1. 购买服务器</h2><p>首先选择合适自己的服务器购买，我最后选择了<a href="https://www.vultr.com/" target="_blank" rel="external">vultr</a>  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/C4BBDBAD5BAF41D1A073B3D8F30A8287?method=download&amp;shareKey=5132e8264adbd7a43ca3976b9628cd60" alt="显示文本"></p>
<p>图中框框的那两个需要勾上<br>可以使用支付宝付钱，但是要预交10美元，扣费好像是根据使用的流量大小。</p>
<h2 id="2-连接服务器"><a href="#2-连接服务器" class="headerlink" title="2. 连接服务器"></a>2. 连接服务器</h2><p>买好服务器后 在服务器列表上会显示服务器的基本信息</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/41A172061BAF4786BBA263DAEDB56A20?method=download&amp;shareKey=3ccde1ec490016e3507e9d9dcf9599d8" alt="显示文本"></p>
<p>一般好像不直接在服务器里直接写命令 ，而是借助了一些三方<br>下载putty：<a href="http://pan.baidu.com/s/1jI0T5Fw" target="_blank" rel="external">http://pan.baidu.com/s/1jI0T5Fw</a> 或者直接在百度搜putty下载解压运行putty.exe</p>
<p>点进服务器详情就可以服务器的IP以及账号密码，运行putty.exe后，我们输入这些信息之后会<br><img src="https://note.youdao.com/yws/api/personal/file/B1BB73F6FE304C1AA7B753D176574FB3?method=download&amp;shareKey=c04a603ebf1a263c8ca218f09be7fb3f" alt="显示文本"><br>显示这个 ，就相当于我们以及成功连接服务器</p>
<h2 id="3-安装shadowsocks"><a href="#3-安装shadowsocks" class="headerlink" title="3. 安装shadowsocks"></a>3. 安装shadowsocks</h2><p>输入这三行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate  https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x shadowsocks.sh</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</div></pre></td></tr></table></figure>
<p>期间，可能提示我们输入密码和端口号，不输入就是默认<br>加密方式我们选择aes-256-cfb，这个没有要求<br>都选择完后，会等待几分钟进行安装，安装之后，终端上会显示你之前设置的信息<br><img src="https://note.youdao.com/yws/api/personal/file/AF1E7166E41D4F9D91DF3BF279FB0697?method=download&amp;shareKey=96eb01a8e1d367656f7f9e18a71f5929" alt="显示文本"><br>我们保存下来这些信息，用于后续连接shadowsocks</p>
<h2 id="4-连接翻墙啦！！！"><a href="#4-连接翻墙啦！！！" class="headerlink" title="4. 连接翻墙啦！！！"></a>4. 连接翻墙啦！！！</h2><p>windows下载地址 <a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="external">https://github.com/shadowsocks/shadowsocks-windows/releases</a>  </p>
<p>客户端教程 <a href="https://www.i5seo.com/windows-mac-ios-android-settings-using-the-ss-ssr-tutorial-client-download/" target="_blank" rel="external">https://www.i5seo.com/windows-mac-ios-android-settings-using-the-ss-ssr-tutorial-client-download/</a><br>下载软件后 输入设置的信息就可以翻墙了</p>
<p>代理模式我们要选择PAC，该模式可以当你浏览特定网站的时候才需要进行翻墙<br><img src="https://note.youdao.com/yws/api/personal/file/B4BF90BC4AA74725849440B8F3A353D6?method=download&amp;shareKey=f3f15525c329a72ac14d23228758ba31" alt="显示文本"></p>
<h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h2><p>如果我们需要<strong>多用户多端口进行连接</strong> 也可以进行相应的配置<br>在刚刚的终端上输入 进入到服务器的这个文件<br>vi /etc/shadowsocks.json<br><img src="https://note.youdao.com/yws/api/personal/file/9ADE75185C5A407997616336BBC1CADB?method=download&amp;shareKey=a53ed155007d8cba412fc4436b81dd69" alt="显示文本"><br>我们可以看看刚刚配置的单用户的信息，我们现在要对里面的数据进行修改<br>（<strong>注意！！！如果进来没有看到这个信息，那证明用户信息不在这个文件中</strong>）  现输入i 进入编辑模式<br>把信息修改成下图，port_password中是配置的端口和用户密码<br><img src="https://note.youdao.com/yws/api/personal/file/CF9D33575CE74038B153CA904042872D?method=download&amp;shareKey=dfd084891d56ec08685c3b94cecc1a2e" alt="显示文本"><br>编辑完后 输入esc退出编辑，然后输入shift+Q进行保存，最后输入wq<br>我们修改好后，需要对shadowssock进行重启  </p>
<p>关闭ShadowSocks服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssserver -c /etc/shadowsocks.json -d stop</div></pre></td></tr></table></figure></p>
<p>启动ShadowSocks服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssserver -c /etc/shadowsocks.json -d start</div></pre></td></tr></table></figure></p>
<p>由此，我们就可以进行多个用户连接了。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><p>由于选择了centerOS6的操作系统 有个巨坑的地方在于我们<strong>需要手动允许设置的端口号通过防火墙</strong><br>输入以下代码，进入防火墙配置信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysconfig/iptables</div></pre></td></tr></table></figure></p>
<p>添加信息到默认的22端口这条规则的下面，按照22端口的规则写就可以<br><img src="https://note.youdao.com/yws/api/personal/file/8C66EB07C57442198B5FC15C4C2A9F7A?method=download&amp;shareKey=a122ed999f698f11dded7c67e7df3171" alt="显示文本"><br>最后重启防火墙使配置生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/iptables restart</div></pre></td></tr></table></figure></p>
<p>多用户就可以用了！！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名优秀的程序员，如果不能看看外面的世界，简直是阻碍了我们进步的脚步，无意间看到一篇博文讲解自己租用服务器来翻墙，所以决定试一试。&lt;br&gt;对比了搬瓦工与vultr及linode三家VPS服务商，最后决定先用vultr的服务器先试一试，一般来说使用离国内越近的位置，速度也越快，东京和新加坡是比较好的选择，买了西雅图的好像也还不错，1080P没有什么问题&lt;br&gt;下面我们来说一说配置的过程&lt;/p&gt;
    
    </summary>
    
      <category term="VPN" scheme="http://yoursite.com/categories/VPN/"/>
    
    
      <category term="VPN" scheme="http://yoursite.com/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>自定义View</title>
    <link href="http://yoursite.com/2018/01/16/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <id>http://yoursite.com/2018/01/16/自定义View/</id>
    <published>2018-01-16T02:59:40.554Z</published>
    <updated>2018-01-19T08:38:51.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义view"><a href="#自定义view" class="headerlink" title="自定义view"></a>自定义view</h1><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)</div><div class="line"> ``` </div><div class="line"> 进行测量   </div><div class="line">```Android</div><div class="line">int widthMode = MeasureSpec.getMode(widthMeasureSpec);  </div><div class="line">int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div></pre></td></tr></table></figure>
</li>
<li><p>onFinishInflate():从xml加载组件后回调</p>
</li>
<li>onSizeChanged():组件大小改变时回调</li>
<li>onLayout():确定显示的位置</li>
<li>onTouchEvent():监听到触摸事件时的回调</li>
</ul>
<a id="more"></a>
<h2 id="三种实现自定义控件的方法"><a href="#三种实现自定义控件的方法" class="headerlink" title="三种实现自定义控件的方法"></a>三种实现自定义控件的方法</h2><ol>
<li>对现有控件进行拓展</li>
<li>通过组合来实现新的控件</li>
<li>重写view来实现全新的控件</li>
</ol>
<h2 id="测量模式"><a href="#测量模式" class="headerlink" title="测量模式"></a>测量模式</h2><ol>
<li>UNSPECIFIED    父容器没有对当前View有任何限制，当前View可以任意取尺寸 </li>
<li>EXACTLY    当前的尺寸就是当前View应该取的尺寸   match_parent以及固定尺寸</li>
<li>AT_MOST    当前尺寸是当前View能取的最大尺寸  wrap_content<br>new Canvas(bitmap)canvas上的所有绘制都是基于bitmap上的</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自定义view&quot;&gt;&lt;a href=&quot;#自定义view&quot; class=&quot;headerlink&quot; title=&quot;自定义view&quot;&gt;&lt;/a&gt;自定义view&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; ``` &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 进行测量   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;```Android&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int widthMode = MeasureSpec.getMode(widthMeasureSpec);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int widthSize = MeasureSpec.getSize(widthMeasureSpec);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;onFinishInflate():从xml加载组件后回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;onSizeChanged():组件大小改变时回调&lt;/li&gt;
&lt;li&gt;onLayout():确定显示的位置&lt;/li&gt;
&lt;li&gt;onTouchEvent():监听到触摸事件时的回调&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Rxjava2分析</title>
    <link href="http://yoursite.com/2018/01/12/RxJava2/"/>
    <id>http://yoursite.com/2018/01/12/RxJava2/</id>
    <published>2018-01-11T16:00:00.000Z</published>
    <updated>2018-01-19T07:31:05.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rxjava的subcribe"><a href="#Rxjava的subcribe" class="headerlink" title="Rxjava的subcribe()"></a>Rxjava的subcribe()</h2><p>首先我们创建一个flowable<br>使用 Flowable.create() 我们获取了一个FlowableCreate对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CheckReturnValue</span></div><div class="line"><span class="meta">@BackpressureSupport</span>(BackpressureKind.SPECIAL)</div><div class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Flowable&lt;T&gt; <span class="title">create</span><span class="params">(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy mode)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</div><div class="line">    ObjectHelper.requireNonNull(mode, <span class="string">"mode is null"</span>);</div><div class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> FlowableCreate&lt;T&gt;(source, mode));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用.subscribe()方法 发现最终都是调用下面的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BackpressureSupport</span>(BackpressureKind.SPECIAL)</div><div class="line">  <span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</div><div class="line">  <span class="meta">@Beta</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableSubscriber&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</div><div class="line">      ObjectHelper.requireNonNull(s, <span class="string">"s is null"</span>);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">/**该方法是对observer进行加工，</span></div><div class="line">          之后可以调用RxJavaPlugins的方法对observer的响应进行修改</div><div class="line">         **/</div><div class="line">          Subscriber&lt;? <span class="keyword">super</span> T&gt; z = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, s);</div><div class="line"></div><div class="line">          ObjectHelper.requireNonNull(z, <span class="string">"Plugin returned null Subscriber"</span>);</div><div class="line">          <span class="comment">/**</span></div><div class="line">          最重要的绑定操作实现在这个方法中，</div><div class="line">          Flowable里是一个抽象方法</div><div class="line">          我们需要到具体的 Flowable的实现类中查看</div><div class="line">         **/</div><div class="line">          subscribeActual(z);</div><div class="line">      &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></div><div class="line">          <span class="keyword">throw</span> e;</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">          Exceptions.throwIfFatal(e);</div><div class="line">          <span class="comment">// can't call onError because no way to know if a Subscription has been set or not</span></div><div class="line">          <span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></div><div class="line">          RxJavaPlugins.onError(e);</div><div class="line"></div><div class="line">          NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</div><div class="line">          npe.initCause(e);</div><div class="line">          <span class="keyword">throw</span> npe;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>我们来查看FlowableCreate里的该方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; t)</span> </span>&#123;</div><div class="line">       BaseEmitter&lt;T&gt; emitter;</div><div class="line">       <span class="comment">//该操作是针对不同情况背压我们使用不同的发射器</span></div><div class="line">       <span class="keyword">switch</span> (backpressure) &#123;</div><div class="line">       <span class="keyword">case</span> MISSING: &#123;</div><div class="line">       <span class="comment">/**没有背压操作的正常的处理此策略表示，通过Create方法创建的Flowable没有指定背压策略，不会对通过OnNext发射的数据做缓存或丢弃处理，需要下游通过背压操作符（onBackpressureBuffer()/onBackpressureDrop()/onBackpressureLatest()）指定背压策略。</span></div><div class="line">       **/</div><div class="line"></div><div class="line">           emitter = <span class="keyword">new</span> MissingEmitter&lt;T&gt;(t);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">case</span> ERROR: &#123;</div><div class="line">       <span class="comment">//抛出MissingBackpressureException异常</span></div><div class="line">           emitter = <span class="keyword">new</span> ErrorAsyncEmitter&lt;T&gt;(t);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">case</span> DROP: &#123;</div><div class="line">       <span class="comment">//Drop就是直接把存不下的事件丢弃</span></div><div class="line">           emitter = <span class="keyword">new</span> DropAsyncEmitter&lt;T&gt;(t);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">case</span> LATEST: &#123;</div><div class="line">       <span class="comment">//只保留最新的事件</span></div><div class="line">           emitter = <span class="keyword">new</span> LatestAsyncEmitter&lt;T&gt;(t);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">default</span>: &#123;</div><div class="line">       <span class="comment">//增大上流缓冲数据的大小</span></div><div class="line">           emitter = <span class="keyword">new</span> BufferAsyncEmitter&lt;T&gt;(t, bufferSize());</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       t.onSubscribe(emitter);</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">    </div><div class="line">           source.subscribe(emitter);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">           Exceptions.throwIfFatal(ex);</div><div class="line">           emitter.onError(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>主要我们查看  t.onSubscribe(emitter);  source.subscribe(emitter);两个方法<br>首先Subscriber中的onSubscribe方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Invoked after calling &#123;<span class="doctag">@link</span> Publisher#subscribe(Subscriber)&#125;.</div><div class="line">   * &lt;p&gt;</div><div class="line">   * No data will start flowing until &#123;<span class="doctag">@link</span> Subscription#request(long)&#125; is invoked.</div><div class="line">   * &lt;p&gt;</div><div class="line">   * It is the responsibility of this &#123;<span class="doctag">@link</span> Subscriber&#125; instance to call &#123;<span class="doctag">@link</span> Subscription#request(long)&#125; whenever more data is wanted.</div><div class="line">   * &lt;p&gt;</div><div class="line">   * The &#123;<span class="doctag">@link</span> Publisher&#125; will send notifications only in response to &#123;<span class="doctag">@link</span> Subscription#request(long)&#125;.</div><div class="line">   * </div><div class="line">   * <span class="doctag">@param</span> s</div><div class="line">   *            &#123;<span class="doctag">@link</span> Subscription&#125; that allows requesting data via &#123;<span class="doctag">@link</span> Subscription#request(long)&#125;</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span></span>;</div></pre></td></tr></table></figure></p>
<p>根据注释我们可以了解 在调用onSubscribe后数据请求才真正的开始，所以当我们使用rxjava的时候 <strong>只有进行订阅后事件请求才开始</strong><br>然后我们看FlowableOnSubscribe的subscribe方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A functional interface that has a &#123;<span class="doctag">@code</span> subscribe()&#125; method that receives</div><div class="line"> * an instance of a &#123;<span class="doctag">@link</span> FlowableEmitter&#125; instance that allows pushing</div><div class="line"> * events in a backpressure-safe and cancellation-safe manner.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt; the value type pushed</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlowableOnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Called for each Subscriber that subscribes.</div><div class="line">     * <span class="doctag">@param</span> e the safe emitter instance, never null</div><div class="line">     * <span class="doctag">@throws</span> Exception on error</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull FlowableEmitter&lt;T&gt; e)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们发现这是一个接口  去查看实现的位置<br>该接口的实现是在Flowable的初始化的时候，也就是我们调用flowable的create方法的时候传入的发射器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CheckReturnValue</span></div><div class="line"> <span class="meta">@BackpressureSupport</span>(BackpressureKind.SPECIAL)</div><div class="line"> <span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Flowable&lt;T&gt; <span class="title">create</span><span class="params">(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy mode)</span> </span>&#123;</div><div class="line">     ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</div><div class="line">     ObjectHelper.requireNonNull(mode, <span class="string">"mode is null"</span>);</div><div class="line">     <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> FlowableCreate&lt;T&gt;(source, mode));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>也就是去消费发射器里的方法 也就实现了观察者中的方法的调用</p>
<p>至此一个链式操作就实现了  </p>
<h2 id="Rxjava-操作符"><a href="#Rxjava-操作符" class="headerlink" title="Rxjava 操作符"></a>Rxjava 操作符</h2><ol>
<li><p>map<br>map是RxJava中最简单的一个变换操作符了,它的作用就是对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化.<br><img src="https://upload-images.jianshu.io/upload_images/1008453-2a068dc6b726568a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/580" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                emitter.onNext(<span class="number">1</span>);</div><div class="line">                emitter.onNext(<span class="number">2</span>);</div><div class="line">                emitter.onNext(<span class="number">3</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;).map(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"This is result "</span> + integer;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.d(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>FlatMap<br>FlatMap将一个发送事件的上游Observable变换为多个发送事件的Observables，然后将它们发射的事件合并后放进一个单独的Observable里.<br><img src="https://upload-images.jianshu.io/upload_images/1008453-659c8c548805fdcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/580" alt=""></p>
</li>
</ol>
<p><strong>flatMap并不保证事件的顺序如果需要保证顺序则需要使用concatMap</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                emitter.onNext(<span class="number">1</span>);</div><div class="line">                emitter.onNext(<span class="number">2</span>);</div><div class="line">                emitter.onNext(<span class="number">3</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;).flatMap(<span class="keyword">new</span> Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">                    list.add(<span class="string">"I am value "</span> + integer);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> Observable.fromIterable(list).delay(<span class="number">10</span>,TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.d(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<ol>
<li>zip<br>Zip通过一个函数将多个Observable发送的事件结合到一起，然后发送这些组合到一起的事件. 它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。<br><img src="https://upload-images.jianshu.io/upload_images/1008453-e11e9d75b1775e4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633" alt=""></li>
</ol>
<p><strong>注意针对每个观察者都要在一个新进程里运行 ，不然会先执行第一个再执行第二个</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Observable&lt;Integer&gt; observable1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;         </div><div class="line">    <span class="meta">@Override</span>                                                                                      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;                   </div><div class="line">        Log.d(TAG, <span class="string">"emit 1"</span>);                                                                      </div><div class="line">        emitter.onNext(<span class="number">1</span>);                                                                         </div><div class="line">        Thread.sleep(<span class="number">1000</span>);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, <span class="string">"emit 2"</span>);                                                                      </div><div class="line">        emitter.onNext(<span class="number">2</span>);                                                                         </div><div class="line">        Thread.sleep(<span class="number">1000</span>);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, <span class="string">"emit 3"</span>);                                                                      </div><div class="line">        emitter.onNext(<span class="number">3</span>);                                                                         </div><div class="line">        Thread.sleep(<span class="number">1000</span>);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, <span class="string">"emit 4"</span>);                                                                      </div><div class="line">        emitter.onNext(<span class="number">4</span>);                                                                         </div><div class="line">        Thread.sleep(<span class="number">1000</span>);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, <span class="string">"emit complete1"</span>);                                                              </div><div class="line">        emitter.onComplete();                                                                      </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribeOn(Schedulers.io());                                                                   </div><div class="line">                                                                                                   </div><div class="line">Observable&lt;String&gt; observable2 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;           </div><div class="line">    <span class="meta">@Override</span>                                                                                      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;                    </div><div class="line">        Log.d(TAG, <span class="string">"emit A"</span>);                                                                      </div><div class="line">        emitter.onNext(<span class="string">"A"</span>);                                                                       </div><div class="line">        Thread.sleep(<span class="number">1000</span>);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, <span class="string">"emit B"</span>);                                                                      </div><div class="line">        emitter.onNext(<span class="string">"B"</span>);                                                                       </div><div class="line">        Thread.sleep(<span class="number">1000</span>);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, <span class="string">"emit C"</span>);                                                                      </div><div class="line">        emitter.onNext(<span class="string">"C"</span>);                                                                       </div><div class="line">        Thread.sleep(<span class="number">1000</span>);                                                                        </div><div class="line">                                                                                                   </div><div class="line">        Log.d(TAG, <span class="string">"emit complete2"</span>);                                                              </div><div class="line">        emitter.onComplete();                                                                      </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribeOn(Schedulers.io());                                                                   </div><div class="line">                                                                                                   </div><div class="line">Observable.zip(observable1, observable2, <span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;() &#123;               </div><div class="line">    <span class="meta">@Override</span>                                                                                      </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer, String s)</span> <span class="keyword">throws</span> Exception </span>&#123;                              </div><div class="line">        <span class="keyword">return</span> integer + s;                                                                        </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;                    </div><div class="line">    <span class="meta">@Override</span>                                                                                      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;                                                        </div><div class="line">        Log.d(TAG, <span class="string">"onSubscribe"</span>);                                                                 </div><div class="line">    &#125;                                                                                              </div><div class="line">                                                                                                   </div><div class="line">    <span class="meta">@Override</span>                                                                                      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String value)</span> </span>&#123;                                                             </div><div class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + value);                                                            </div><div class="line">    &#125;                                                                                              </div><div class="line">                                                                                                   </div><div class="line">    <span class="meta">@Override</span>                                                                                      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;                                                             </div><div class="line">        Log.d(TAG, <span class="string">"onError"</span>);                                                                     </div><div class="line">    &#125;                                                                                              </div><div class="line">                                                                                                   </div><div class="line">    <span class="meta">@Override</span>                                                                                      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;                                                                     </div><div class="line">        Log.d(TAG, <span class="string">"onComplete"</span>);                                                                  </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="背压"><a href="#背压" class="headerlink" title="背压"></a><a href="https://www.jianshu.com/p/9b1304435564" target="_blank" rel="external">背压</a></h2><p>这是因为Flowable在设计的时候采用了一种新的思路也就是响应式拉取的方式来更好的解决上下游流速不均衡的问题, 与我们之前所讲的控制数量和控制速度不太一样, 这种方式用通俗易懂的话来说就好比是叶问打鬼子, 我们把上游看成小日本, 把下游当作叶问, 当调用Subscription.request(1)时, 叶问就说我要打一个! 然后小日本就拿出一个鬼子给叶问, 让他打, 等叶问打死这个鬼子之后, 再次调用request(10), 叶问就又说我要打十个! 然后小日本又派出十个鬼子给叶问, 然后就在边上看热闹, 看叶问能不能打死十个鬼子, 等叶问打死十个鬼子后再继续要鬼子接着打…</p>
<p>所以我们把request当做是一种能力, 当成下游处理事件的能力, 下游能处理几个就告诉上游我要几个, 这样只要上游根据下游的处理能力来决定发送多少事件, 就不会造成一窝蜂的发出一堆事件来, 从而导致OOM. 这也就完美的解决之前我们所学到的两种方式的缺陷, 过滤事件会导致事件丢失, 减速又可能导致性能损失. 而这种方式既解决了事件丢失的问题, 又解决了速度的问题, 完美 !</p>
<p><strong>针对Flowable 由于是下游需要几个 就调用request方法取几个，所以 如果实现Subscriber的时候 在onSubscribe方法中需要调用t.request(Long.MAX_VALUE);<br>当然如果我们只使用onNext等方法可以不需要</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">   <span class="meta">@CheckReturnValue</span></div><div class="line">    <span class="meta">@BackpressureSupport</span>(BackpressureKind.SPECIAL)</div><div class="line">    <span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError,</span></span></div><div class="line">            Action onComplete, Consumer&lt;? <span class="keyword">super</span> Subscription&gt; onSubscribe) &#123;</div><div class="line">        ObjectHelper.requireNonNull(onNext, <span class="string">"onNext is null"</span>);</div><div class="line">        ObjectHelper.requireNonNull(onError, <span class="string">"onError is null"</span>);</div><div class="line">        ObjectHelper.requireNonNull(onComplete, <span class="string">"onComplete is null"</span>);</div><div class="line">        ObjectHelper.requireNonNull(onSubscribe, <span class="string">"onSubscribe is null"</span>);</div><div class="line"><span class="comment">//在绑定的时候我们可以看到都生成了一个LambdaSubscriber观察者</span></div><div class="line">        LambdaSubscriber&lt;T&gt; ls = <span class="keyword">new</span> LambdaSubscriber&lt;T&gt;(onNext, onError, onComplete, onSubscribe);</div><div class="line"></div><div class="line">        subscribe(ls);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ls;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>根据之前的分析 在subscribeActual中实际执行了        t.onSubscribe(emitter);<br>我们回到LambdaSubscriber中看该方法实现了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (SubscriptionHelper.setOnce(<span class="keyword">this</span>, s)) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            onSubscribe.accept(<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">            Exceptions.throwIfFatal(ex);</div><div class="line">            s.cancel();</div><div class="line">            onError(ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们发现他执行了accept方法  然后我们回到Flowable的subscribe方法看 ，发现如果我们没有传onSubscribe系统会默认传入FlowableInternalHelper.RequestMax.INSTANCE<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RequestMax implements Consumer&lt;Subscription&gt; &#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Subscription t)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        t.request(Long.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里实现了下游 获取数据 所以我们不需要自己去实现</p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>Flowable上游有一个缓冲池 ，当同步加载的时候，就是下游request一个，上游取一个，（当上下游工作在同一个线程中时, 这时候是一个同步的订阅关系, 也就是说上游每发送一个事件必须等到下游接收处理完了以后才能接着发送下一个事件）但是当异步请求的时候，上游自身有一个request这个request=128 意味着上游的缓冲池可以放128个数据，<br>上游按照需要把onnext方法请求放入缓冲池 ，假设我们放入1个,按理下游取出1个，那缓冲池的数据将减小一，但是事实不是这样的，当我们下游执行到96个数据的时候，缓冲池才会进行一遍清理，将没有用的数据清除，上游的request就会等于128减去缓冲池里未处理的数据。<br>而MissingBackpressureException的产生原因就是上下游数据处理速度不一致，假设上游处理的更快，我们放入了128个数据，但是下游处理的事件不到96个，那么如果再发送数据的话，缓冲池接受不了 就会抛出异常，我们设置的背压策略就是为了解决这个问题的<br>我们也可以当上游在e.requested()等于0时，暂停发射数据，便可解决背压问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Rxjava的subcribe&quot;&gt;&lt;a href=&quot;#Rxjava的subcribe&quot; class=&quot;headerlink&quot; title=&quot;Rxjava的subcribe()&quot;&gt;&lt;/a&gt;Rxjava的subcribe()&lt;/h2&gt;&lt;p&gt;首先我们创建一个flowable&lt;br&gt;使用 Flowable.create() 我们获取了一个FlowableCreate对象&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@CheckReturnValue&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@BackpressureSupport&lt;/span&gt;(BackpressureKind.SPECIAL)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SchedulerSupport&lt;/span&gt;(SchedulerSupport.NONE)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Flowable&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(FlowableOnSubscribe&amp;lt;T&amp;gt; source, BackpressureStrategy mode)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ObjectHelper.requireNonNull(source, &lt;span class=&quot;string&quot;&gt;&quot;source is null&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ObjectHelper.requireNonNull(mode, &lt;span class=&quot;string&quot;&gt;&quot;mode is null&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; RxJavaPlugins.onAssembly(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FlowableCreate&amp;lt;T&amp;gt;(source, mode));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用.subscribe()方法 发现最终都是调用下面的方法&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@BackpressureSupport&lt;/span&gt;(BackpressureKind.SPECIAL)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@SchedulerSupport&lt;/span&gt;(SchedulerSupport.NONE)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Beta&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(FlowableSubscriber&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; T&amp;gt; s)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      ObjectHelper.requireNonNull(s, &lt;span class=&quot;string&quot;&gt;&quot;s is null&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;/**该方法是对observer进行加工，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          之后可以调用RxJavaPlugins的方法对observer的响应进行修改&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         **/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          Subscriber&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; T&amp;gt; z = RxJavaPlugins.onSubscribe(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, s);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          ObjectHelper.requireNonNull(z, &lt;span class=&quot;string&quot;&gt;&quot;Plugin returned null Subscriber&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          最重要的绑定操作实现在这个方法中，&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          Flowable里是一个抽象方法&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          我们需要到具体的 Flowable的实现类中查看&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         **/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          subscribeActual(z);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (NullPointerException e) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// NOPMD&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; e;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          Exceptions.throwIfFatal(e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// can&#39;t call onError because no way to know if a Subscription has been set or not&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// can&#39;t call onSubscribe because the call might have set a Subscription already&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          RxJavaPlugins.onError(e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          NullPointerException npe = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;string&quot;&gt;&quot;Actually not, but can&#39;t throw other exceptions due to RS&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          npe.initCause(e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; npe;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin泛型</title>
    <link href="http://yoursite.com/2018/01/10/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/01/10/泛型/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2018-01-19T10:14:14.915Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>泛型中上界和下界的定义<br>上界 &lt;? extend Fruit&gt;<br>下界 &lt;? super Apple&gt;  </li>
</ol>
<p>2.上界和下界的特点<br>上界的list只能get，不能add（确切地说不能add出除null之外的对象，包括Object）<br>下界的list只能add，不能get<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;  </div><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">    <span class="comment">//上界  </span></div><div class="line">    List&lt;? extends Fruit&gt; flistTop = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();  </div><div class="line">    flistTop.add(<span class="keyword">null</span>);  </div><div class="line">    <span class="comment">//add Fruit对象会报错  </span></div><div class="line">    <span class="comment">//flist.add(new Fruit());  </span></div><div class="line">    Fruit fruit1 = flistTop.get(<span class="number">0</span>);  </div><div class="line">  </div><div class="line">    <span class="comment">//下界  </span></div><div class="line">    List&lt;? <span class="keyword">super</span> Apple&gt; flistBottem = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();  </div><div class="line">    flistBottem.add(<span class="keyword">new</span> Apple());  </div><div class="line">    flistBottem.add(<span class="keyword">new</span> Jonathan());  </div><div class="line">    <span class="comment">//get Apple对象会报错  </span></div><div class="line">    <span class="comment">//Apple apple = flistBottem.get(0);  </span></div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="这些特点的原因"><a href="#这些特点的原因" class="headerlink" title="这些特点的原因"></a>这些特点的原因</h3><h4 id="上界-lt-extend-Fruit-gt"><a href="#上界-lt-extend-Fruit-gt" class="headerlink" title="上界 &lt;? extend Fruit&gt;"></a>上界 &lt;? extend Fruit&gt;</h4><p>表示所有继承Fruit的子类，但是具体是哪个子类，无法确定，所以调用add的时候，要add什么类型，谁也不知道。但是get的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是Fruit，所以，我都可以用最大的父类Fruit接着，也就是把所有的子类向上转型为Fruit。  </p>
<h4 id="下界-lt-super-Apple-gt"><a href="#下界-lt-super-Apple-gt" class="headerlink" title="下界 &lt;? super Apple&gt;"></a>下界 &lt;? super Apple&gt;</h4><p>表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我add的时候，我不能add Apple的父类，因为不能确定List里面存放的到底是哪个父类。但是我可以add Apple及其子类。因为不管我的子类是什么类型，它都可以向上转型为Apple及其所有的父类甚至转型为Object。但是当我get的时候，Apple的父类这么多，我用什么接着呢，除了Object，其他的都接不住。<br>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。具体来讲，我可以把Apple对象赋值给Fruit的引用，但是如果把Fruit对象赋值给Apple的引用就必须得用cast。</p>
<h2 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h2><p>1、 Kotlin的泛型使用基本和Java一致</p>
<p>2、 Java的 <code>&lt;? extends T&gt;</code> 相当于 Kotlin的<code>&lt;out T&gt;</code>，Java的<figure class="highlight plain"><figcaption><span>super T>``` 相当于 Kotlin的```<in t="">```</in></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3、```&lt;out T&gt;``` 只能生产(出参)， ```&lt;in T&gt;``` 只能消费(入参)</div><div class="line"></div><div class="line">4、```&lt;out T&gt;``` 只能生产的原因是编译器无法确认什么对象符合那个未知的 T 的子类型，只知道一定返回T，```&lt;in T&gt; ```只能消费的原因是无法确认T超类的具体类型</div><div class="line"></div><div class="line">5、```&lt;*&gt;```相当于java中的无泛型。对于 Foo ```&lt;out T&gt;```，其中 T 是一个具有上界的协变类型参数,```Foo &lt;*&gt;``` 等价于 ```Foo &lt;out Any&gt;```;对于 ```Foo &lt;in T&gt;```，其中 T 是一个逆变类型参数，```Foo &lt;*&gt; ```等价于``` Foo &lt;in Nothing&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;泛型中上界和下界的定义&lt;br&gt;上界 &amp;lt;? extend Fruit&amp;gt;&lt;br&gt;下界 &amp;lt;? super Apple&amp;gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2.上界和下界的特点&lt;br&gt;上界的list只能get，不能add（确切地说不能add出除null之外的对象，包括Object）&lt;br&gt;下界的list只能add，不能get&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.ArrayList;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.List;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fruit&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fruit&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Jonathan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Orange&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fruit&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CovariantArrays&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//上界  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    List&amp;lt;? extends Fruit&amp;gt; flistTop = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Apple&amp;gt;();  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    flistTop.add(&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//add Fruit对象会报错  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//flist.add(new Fruit());  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Fruit fruit1 = flistTop.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//下界  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    List&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; Apple&amp;gt; flistBottem = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Apple&amp;gt;();  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    flistBottem.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Apple());  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    flistBottem.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Jonathan());  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//get Apple对象会报错  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//Apple apple = flistBottem.get(0);  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>新年新Flag</title>
    <link href="http://yoursite.com/2018/01/01/%E6%96%B0%E5%B9%B4%E6%96%B0Flag/"/>
    <id>http://yoursite.com/2018/01/01/新年新Flag/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2018-01-19T08:42:47.339Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>今年至少要使用kotlin写一个项目，熟悉基本的kotlin语法（使用官方的MVP）</li>
<li>熟练使用RxJava2 并不限于网络请求使用</li>
<li>抽时间发布博客，多学一下面试相关的题目</li>
<li>学习使用gradle，包括多渠道打包以及分类型打包</li>
<li>了解binder机制，知道Android启动过程，多了解一下底层相关的知识</li>
<li>学习插件化，组件化，热更新</li>
<li>了解一下Dagger</li>
<li>看完Java编程思想以及Android开发艺术探索<a id="more"></a>
博客内容</li>
<li>性能优化</li>
<li>内存泄漏与内存溢出</li>
<li>回收机制</li>
<li>Glide源码分析</li>
<li>事件分发机制</li>
<li>View绘制流程</li>
<li>Android6.0权限处理</li>
<li>Java发射以及hook</li>
<li>排序算法</li>
<li>设计模式学习</li>
<li>热更新以及插件化  </li>
<li>Android每一代更新的功能</li>
<li>Http相关知识</li>
<li>自定义view</li>
<li>完善gradle的博客内容</li>
</ol>
<p>Emmmm…等待补充</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;今年至少要使用kotlin写一个项目，熟悉基本的kotlin语法（使用官方的MVP）&lt;/li&gt;
&lt;li&gt;熟练使用RxJava2 并不限于网络请求使用&lt;/li&gt;
&lt;li&gt;抽时间发布博客，多学一下面试相关的题目&lt;/li&gt;
&lt;li&gt;学习使用gradle，包括多渠道打包以及分类型打包&lt;/li&gt;
&lt;li&gt;了解binder机制，知道Android启动过程，多了解一下底层相关的知识&lt;/li&gt;
&lt;li&gt;学习插件化，组件化，热更新&lt;/li&gt;
&lt;li&gt;了解一下Dagger&lt;/li&gt;
&lt;li&gt;看完Java编程思想以及Android开发艺术探索
    
    </summary>
    
      <category term="计划" scheme="http://yoursite.com/categories/%E8%AE%A1%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>SmartRefreshLayout源码解析</title>
    <link href="http://yoursite.com/2017/12/29/SmartRefreshLayout/"/>
    <id>http://yoursite.com/2017/12/29/SmartRefreshLayout/</id>
    <published>2017-12-28T16:00:00.000Z</published>
    <updated>2018-01-16T07:14:59.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="onFinishInflate"><a href="#onFinishInflate" class="headerlink" title="onFinishInflate"></a>onFinishInflate</h3><p>View.inflate (context,R.layout.my_view,null)当加载完成xml后，就会执行这个方法。<br>在该方法中将refreshContent,refreshHead,refreshfoot确认<br>refreshHead,refreshfoot这两个类 是接口<br>RefreshFooterWrapper，RefreshHeaderWrapper是该接口包装类，该类主要是针对上拉下拉操作过程的一些手势和时刻的动画 View不能超过3个</p>
<h3 id="RefreshHeaderWrapper"><a href="#RefreshHeaderWrapper" class="headerlink" title="RefreshHeaderWrapper"></a>RefreshHeaderWrapper</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 刷新头部包装</div><div class="line"> * Created by SCWANG on 2017/5/26.</div><div class="line"> */</div><div class="line"></div><div class="line">public class RefreshHeaderWrapper implements RefreshHeader &#123;</div><div class="line"></div><div class="line">    private View mWrapperView;</div><div class="line">    private SpinnerStyle mSpinnerStyle;</div><div class="line"></div><div class="line">    public RefreshHeaderWrapper(View wrapper) &#123;</div><div class="line">        this.mWrapperView = wrapper;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @NonNull</div><div class="line">    public View getView() &#123;</div><div class="line">        return mWrapperView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int onFinish(@NonNull RefreshLayout layout, boolean success) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override@Deprecated</div><div class="line">    public void setPrimaryColors(@ColorInt int ... colors) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @NonNull</div><div class="line">    @Override</div><div class="line">    public SpinnerStyle getSpinnerStyle() &#123;</div><div class="line">        if (mSpinnerStyle != null) &#123;</div><div class="line">            return mSpinnerStyle;</div><div class="line">        &#125;</div><div class="line">        ViewGroup.LayoutParams params = mWrapperView.getLayoutParams();</div><div class="line">        if (params instanceof SmartRefreshLayout.LayoutParams) &#123;</div><div class="line">            mSpinnerStyle = ((SmartRefreshLayout.LayoutParams) params).spinnerStyle;</div><div class="line">            if (mSpinnerStyle != null) &#123;</div><div class="line">                return mSpinnerStyle;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (params != null) &#123;</div><div class="line">            if (params.height == ViewGroup.LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                return mSpinnerStyle = SpinnerStyle.Scale;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return mSpinnerStyle = SpinnerStyle.Translate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onInitialized(@NonNull RefreshKernel kernel, int height, int extendHeight) &#123;</div><div class="line">        ViewGroup.LayoutParams params = mWrapperView.getLayoutParams();</div><div class="line">        if (params instanceof SmartRefreshLayout.LayoutParams) &#123;</div><div class="line">            kernel.requestDrawBackgoundForHeader(((SmartRefreshLayout.LayoutParams) params).backgroundColor);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean isSupportHorizontalDrag() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onHorizontalDrag(float percentX, int offsetX, int offsetMax) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onPullingDown(float percent, int offset, int headHeight, int extendHeight) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onReleasing(float percent, int offset, int headHeight, int extendHeight) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onRefreshReleased(RefreshLayout layout, int headerHeight, int extendHeight) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onStartAnimator(@NonNull RefreshLayout layout, int headHeight, int extendHeight) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onStateChanged(RefreshLayout refreshLayout, RefreshState oldState, RefreshState newState) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RefreshHeader"><a href="#RefreshHeader" class="headerlink" title="RefreshHeader"></a>RefreshHeader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * 刷新头部</div><div class="line"> * Created by SCWANG on 2017/5/26.</div><div class="line"> */</div><div class="line">@RestrictTo(&#123;LIBRARY_GROUP,SUBCLASSES&#125;)</div><div class="line">public interface RefreshHeader extends RefreshInternal &#123;</div><div class="line">    /**</div><div class="line">     * 手指拖动下拉（会连续多次调用）</div><div class="line">     * @param percent 下拉的百分比 值 = offset/headerHeight (0 - percent - (headerHeight+extendHeight) / headerHeight )</div><div class="line">     * @param offset 下拉的像素偏移量  0 - offset - (headerHeight+extendHeight)</div><div class="line">     * @param headerHeight Header的高度</div><div class="line">     * @param extendHeight Header的扩展高度</div><div class="line">     */</div><div class="line">    void onPullingDown(float percent, int offset, int headerHeight, int extendHeight);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 手指释放之后的持续动画</div><div class="line">     * @param percent 下拉的百分比 值 = offset/headerHeight (0 - percent - (headerHeight+extendHeight) / headerHeight )</div><div class="line">     * @param offset 下拉的像素偏移量  0 - offset - (headerHeight+extendHeight)</div><div class="line">     * @param headerHeight Header的高度</div><div class="line">     * @param extendHeight Header的扩展高度</div><div class="line">     */</div><div class="line">    void onReleasing(float percent, int offset, int headerHeight, int extendHeight);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 释放时刻（调用一次，将会触发加载）</div><div class="line">     * @param layout RefreshLayout</div><div class="line">     * @param headerHeight HeaderHeight</div><div class="line">     * @param extendHeight extendHeaderHeight or extendFooterHeight</div><div class="line">     */</div><div class="line">    void onRefreshReleased(RefreshLayout layout, int headerHeight, int extendHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RefreshInternal"><a href="#RefreshInternal" class="headerlink" title="RefreshInternal"></a>RefreshInternal</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 刷新内部组件</div><div class="line"> * Created by SCWANG on 2017/5/26.</div><div class="line"> */</div><div class="line">@RestrictTo(&#123;LIBRARY_GROUP,SUBCLASSES&#125;)</div><div class="line">public interface RefreshInternal extends OnStateChangedListener &#123;</div><div class="line">    /**</div><div class="line">     * 获取实体视图</div><div class="line">     */</div><div class="line">    @NonNull</div><div class="line">    View getView();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取变换方式 &#123;@link SpinnerStyle&#125; 必须返回 非空</div><div class="line">     */</div><div class="line">    @NonNull</div><div class="line">    SpinnerStyle getSpinnerStyle();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 设置主题颜色</div><div class="line">     * @param colors 对应Xml中配置的 srlPrimaryColor srlAccentColor</div><div class="line">     */</div><div class="line">    void setPrimaryColors(@ColorInt int... colors);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 尺寸定义完成 （如果高度不改变（代码修改：setHeader），只调用一次, 在RefreshLayout#onMeasure中调用）</div><div class="line">     * @param kernel RefreshKernel</div><div class="line">     * @param height HeaderHeight or FooterHeight</div><div class="line">     * @param extendHeight extendHeaderHeight or extendFooterHeight</div><div class="line">     */</div><div class="line">    void onInitialized(@NonNull RefreshKernel kernel, int height, int extendHeight);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 水平方向的拖动</div><div class="line">     * @param percentX 下拉时，手指水平坐标对屏幕的占比（0 - percentX - 1）</div><div class="line">     * @param offsetX 下拉时，手指水平坐标对屏幕的偏移（0 - offsetX - LayoutWidth）</div><div class="line">     */</div><div class="line">    void onHorizontalDrag(float percentX, int offsetX, int offsetMax);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 开始动画</div><div class="line">     * @param layout RefreshLayout</div><div class="line">     * @param height HeaderHeight or FooterHeight</div><div class="line">     * @param extendHeight extendHeaderHeight or extendFooterHeight</div><div class="line">     */</div><div class="line">    void onStartAnimator(@NonNull RefreshLayout layout, int height, int extendHeight);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 动画结束</div><div class="line">     * @param layout RefreshLayout</div><div class="line">     * @param success 数据是否成功刷新或加载</div><div class="line">     * @return 完成动画所需时间 如果返回 Integer.MAX_VALUE 将取消本次完成事件，继续保持原有状态</div><div class="line">     */</div><div class="line">    int onFinish(@NonNull RefreshLayout layout, boolean success);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否支持水平方向的拖动（将会影响到onHorizontalDrag的调用）</div><div class="line">     * @return 水平拖动需要消耗更多的时间和资源，所以如果不支持请返回false</div><div class="line">     */</div><div class="line">    boolean isSupportHorizontalDrag();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="onAttachedToWindow"><a href="#onAttachedToWindow" class="headerlink" title="onAttachedToWindow"></a>onAttachedToWindow</h3><p>判断是不是有head和foot 布局 没有 加载默认布局<br>对head和foot进行默认下拉上拉的监听<br>如果有固定在content的布局进行添加</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>计算head foot 以及content的尺寸</p>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><p>计算head foot 以及content在页面上的位置</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;onFinishInflate&quot;&gt;&lt;a href=&quot;#onFinishInflate&quot; class=&quot;headerlink&quot; title=&quot;onFinishInflate&quot;&gt;&lt;/a&gt;onFinishInflate&lt;/h3&gt;&lt;p&gt;View.inflate (cont
    
    </summary>
    
      <category term="源码解析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Android底层知识</title>
    <link href="http://yoursite.com/2017/12/22/Android%20%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2017/12/22/Android 底层知识/</id>
    <published>2017-12-21T16:00:00.000Z</published>
    <updated>2018-01-16T08:03:20.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1><p>1) 首先，Binder分为Client和Server两个进程。<br>2) 图中的IPC就是进程间通信的意思。<br>图中的ServiceManager，负责把Binder Server注册到一个容器中。<br>ServiceManager比喻成电话局，存储着每个住宅的座机电话，还是很恰当的。张三给李四打电话，拨打电话号码，会先转接到电话局，电话局的接线员查到这个电话号码的地址，因为李四的电话号码之前在电话局注册过，所以就能拨通；没注册，就会提示该号码不存在。<br>对照着Android Binder机制，对着上面这图，张三就是Binder Client，李四就是Binder Server，电话局就是ServiceManager，电话局的接线员在这个过程中做了很多事情，对应着图中的Binder驱动</p>
<p><img src="http://images2015.cnblogs.com/blog/13430/201705/13430-20170516223325025-1448613892.png" alt=""></p>
<p> 3) Client想要直接调用Server的add方法，是不可以的，因为它们在不同的进程中，这时候就需要Binder来帮忙了。<br>首先是Server在SM这个容器中注册。其次，Client想要调用Server的add方法，就需要先获取Server对象， 但是SM不会把真正的Server对象返回给Client，而是把Server的一个代理对象返回给Client，也就是Proxy。然后，Client调用Proxy的add方法，SM会帮他去调用Server的add方法，并把结果返回给Client。<br> <img src="http://images2015.cnblogs.com/blog/13430/201705/13430-20170516223354650-984999229.png" alt=""></p>
<h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h1><p> Android系统中很多系统服务都是aidl，比如说剪切板<br> AIDL中需要知道下面几个类：</p>
<ul>
<li>IBinder</li>
<li>IInterface</li>
<li>Binder</li>
<li>Proxy</li>
<li>Stub </li>
</ul>
<p>当我们自定义一个aidl文件时（比如MyAidl.aidl，里面有一个sum方法），Android Studio会帮我们生成一个类文件MyAidl.java，如下图所示：<br> <img src="http://images2015.cnblogs.com/blog/13430/201705/13430-20170516223432791-1010721944.png" alt=""></p>
<p>MyAidl.java这个生成文件中，包括MyAidl接口，以及Stub和Proxy两个实现了MyAidl接口的类，其中Stub是定义在MyAidl接口中的，而Proxy则定义在Stub类中。为什么要嵌套那么多层级，因为有多个AIDL类的时候，Stub和Proxy类就会重名，把它们放在各自的AIDL接口中，就必须MyAidl.Stub这样去使用，就区分开了。<br> <img src="http://images2015.cnblogs.com/blog/13430/201705/13430-20170516223504650-228437964.png" alt=""><br> 1) 从Client看起，对于AIDL的使用者，我们这么写程序：MyAidl.Stub.asInterface(某IBinder对象).sum(1, 2);         //最好在执行sum方法前判空。<br>asInterface方法的作用是判断参数——也就是IBinder对象，和自己是否在同一个进程：</p>
<ul>
<li>是，则直接转换、直接使用，接下来就跟Binder跨进程通信无关啦；</li>
<li><p>否，则把这个IBinder参数包装成一个Proxy对象，这时调用Stub的sum方法，间接调用Proxy的sum方法。return new MyAidl.Stub.Proxy(obj);<br>2) Proxy在自己的sum方法中，会使用Parcelable来准备数据，把函数名称、函数参数都写入_data，让_reply接收函数返回值。最后使用IBinder的transact方法，把数据就传给Binder的Server端了。mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); //这里的mRemote就是asInterface方法传过来的obj参数</p>
<p>3) Server则是通过onTransact方法接收Client进程传过来的数据，包括函数名称、函数参数，找到对应的函数，这里是sum，把参数喂进去，得到结果，返回。<br>所以onTransact函数经历了读数据–&gt;执行要调用的函数–&gt;把执行结果再写数据的过程</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binder&quot;&gt;&lt;a href=&quot;#Binder&quot; class=&quot;headerlink&quot; title=&quot;Binder&quot;&gt;&lt;/a&gt;Binder&lt;/h1&gt;&lt;p&gt;1) 首先，Binder分为Client和Server两个进程。&lt;br&gt;2) 图中的IPC就是进程间通信的意
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>进程 线程</title>
    <link href="http://yoursite.com/2017/12/21/%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/12/21/进程 线程/</id>
    <published>2017-12-20T16:00:00.000Z</published>
    <updated>2018-01-16T07:17:05.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p> 为了确定保留或终止哪些进程，系统会根据进程中<strong>正在运行的组件</strong>以及这些组件的状态，将每个进程放入“重要性层次结构”中。 例如，如果某进程托管着服务和可见 Activity，则会将此进程评定为可见进程，而不是服务进程。  </p>
<h2 id="按照重要程度分为（第一个进程最重要，将是最后一个被终止的进程）"><a href="#按照重要程度分为（第一个进程最重要，将是最后一个被终止的进程）" class="headerlink" title="按照重要程度分为（第一个进程最重要，将是最后一个被终止的进程）"></a>按照重要程度分为（第一个进程最重要，将是最后一个被终止的进程）</h2><h3 id="1-前台进程"><a href="#1-前台进程" class="headerlink" title="1. 前台进程"></a>1. 前台进程</h3><p>当前用户操作所需要的进程，如果一个进程满足以下任一条件，即视为前台进程：</p>
<ul>
<li>正在交互的 Activity（已调用 Activity 的 onResume() 方法）  </li>
<li>某个 Service，绑定到用户正在交互的 Activity  </li>
<li>正在“前台”运行的 Service（服务已调用 startForeground()）  </li>
<li>正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）  </li>
<li>正执行其 onReceive() 方法的 BroadcastReceiver  <h3 id="2-可见进程"><a href="#2-可见进程" class="headerlink" title="2. 可见进程"></a>2. 可见进程</h3>没有任何前台组件、但是仍然会影响到用户在屏幕上所见内容的进程</li>
<li>不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity - 启动了一个对话框，允许在其后显示上一Activity，则有可能会发生这种情况</li>
<li>绑定到可见（或前台）Activity 的 Service。<h3 id="3-服务进程"><a href="#3-服务进程" class="headerlink" title="3. 服务进程"></a>3. 服务进程</h3>正在运行使用了startservice()方法启动的服务，但是又不属于上面两种高级别进程，虽然服务进程和用户所见内容没有关系，但是他们正在执行一些用户关心的操作（例如网络请求，播放音乐）</li>
</ul>
<h3 id="4-后台进程"><a href="#4-后台进程" class="headerlink" title="4. 后台进程"></a>4. 后台进程</h3><p>目前对用户不可见的Activity进程（已经调用了activity的onstop()方法），这些进程对用户体验没有任何影响 ，系统可以随时终止，这些进程 一般保存在LRU(最近最少使用)队列中，这样可以保证被销毁的是用户最早查看的进程，如果用户在Activity中做了保存状态的操作 ， 那之后重启的时候可以进行状态恢复</p>
<h3 id="5-空进程"><a href="#5-空进程" class="headerlink" title="5. 空进程"></a>5. 空进程</h3><p>不包含任何组件的进程，保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间  </p>
<h2 id="按照功能分类"><a href="#按照功能分类" class="headerlink" title="按照功能分类"></a>按照功能分类</h2><h3 id="1-系统进程"><a href="#1-系统进程" class="headerlink" title="1. 系统进程"></a>1. 系统进程</h3><p>数量是固定的 ，并且长时间存在于内存中，不会被杀死</p>
<ul>
<li>管理硬件设备</li>
<li>提供访问设备的基本能力</li>
<li>管理应用进程<h3 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h3>系统的第一个进程，进程号为1，掌握整个系统的运行逻辑，由于Android系统在不同设备的运行方式不一定相同，为了适应各种平台和设备的需求，init进程的初始化工作通过init.rc配置文件来管理。</li>
</ul>
<p>init.rc中配置了系统启动的时候该做哪些事情，以及启动哪些系统进程。</p>
<h3 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h3><p>zygote的中文意思是“受精卵“。这是一个很有寓意的名称：所有的应用进程都是由zygote fork出来的子进程，因此zygote进程是所有应用进程的父进程。<br>zygote进程启动之后，会启动一个socket套接字，并通过Looper一直在这个套接字上等待连接。<br><strong>所有应用进程都是通过发送数据到这个套接字上，然后由zygote进程创建的。</strong><br>在该进程中，会通过preload方法预加载应用程序需要的公共资源，这样有两个好处：  </p>
<ul>
<li>加快应用启动速度</li>
<li>使用共享资源的话 ，可以节省内存<h3 id="system-server进程"><a href="#system-server进程" class="headerlink" title="system_server进程"></a>system_server进程</h3>系统服务器,Framework层的几乎所有服务都位于这个进程中。这其中就包括管理四大组件的ActivityManagerService。<br>包含很多系统服务</li>
<li>负责网络管理的NetworkManagementService</li>
<li>负责窗口管理的WindowManagerService</li>
<li>负责震动管理的VibratorService</li>
<li>负责输入管理的InputManagerService<h3 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h3><strong>所有应用程序的进程都是由ActivityManagerService通过socket发送请求给Zygote进程，然后由zygote fork创建的</strong><br>ActivityManagerService通过Process.start方法来请求zygote创建进程：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static final ProcessStartResult start(final String processClass,</div><div class="line">                             final String niceName,</div><div class="line">                             int uid, int gid, int[] gids,</div><div class="line">                             int debugFlags, int mountExternal,</div><div class="line">                             int targetSdkVersion,</div><div class="line">                             String seInfo,</div><div class="line">                             String abi,</div><div class="line">                             String instructionSet,</div><div class="line">                             String appDataDir,</div><div class="line">                             String[] zygoteArgs) &#123;</div><div class="line">   try &#123;</div><div class="line">       return startViaZygote(processClass, niceName, uid, gid, gids,</div><div class="line">               debugFlags, mountExternal, targetSdkVersion, seInfo,</div><div class="line">               abi, instructionSet, appDataDir, zygoteArgs);</div><div class="line">   &#125; catch (ZygoteStartFailedEx ex) &#123;</div><div class="line">       Log.e(LOG_TAG,</div><div class="line">               &quot;Starting VM process through Zygote failed&quot;);</div><div class="line">       throw new RuntimeException(</div><div class="line">               &quot;Starting VM process through Zygote failed&quot;, ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>对于每一个应用进程，在ActivityManagerService中，都有一个ProcessRecord与之对应。这个对象记录了应用进程的所有详细状态。</strong></p>
<p>ProcessRecord记录了以下信息：</p>
<ul>
<li>activities 记录进程中运行的Activity</li>
<li>services,excutingServices 记录进程中运行的Service</li>
<li>receivers 记录进程中运行的BroadCastReceiver</li>
<li>pubProviders 记录进程中运行的ContentProvider</li>
<li>connections 记录了对于Service的连接</li>
<li>conProviders 记录了对于ContentProvider的连接<br><img src="https://upload-images.jianshu.io/upload_images/4048192-522905df79b4c116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="显示文本"></li>
</ul>
<h3 id="2-应用进程"><a href="#2-应用进程" class="headerlink" title="2. 应用进程"></a>2. 应用进程</h3><p>应用进程和ActivityManagerService所在进程（即system_server进程）是相互独立的，两个进程之间的方法通常是不能直接互相调用的。一般通过binder实现</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4048192-862293248ed47fc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="显示文本"></p>
<h3 id="进程优先级算法"><a href="#进程优先级算法" class="headerlink" title="进程优先级算法"></a>进程优先级算法</h3><p><img src="https://upload-images.jianshu.io/upload_images/4048192-491f58b875a23868.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/696" alt="显示文本"></p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p> Android单线程必须遵守两条原则：</p>
<ul>
<li>不要阻塞 UI 线程</li>
<li>不要在 UI 线程之外访问 Android UI 工具包</li>
</ul>
<p>如果需要在工作线程中对UI进行操作，可以从其他线程访问 UI 线程 可使用：</p>
<ul>
<li>Activity.runOnUiThread(Runnable)</li>
<li>View.post(Runnable)</li>
<li>View.postDelayed(Runnable, long)<br>要通过工作线程处理更复杂的交互，可以考虑在工作线程中使用 Handler 处理来自 UI 线程的消息，也可以扩展 AsyncTask 类，此类简化了与 UI 进行交互所需执行的工作线程任务</li>
</ul>
<h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><p>内存回收分为两部分：</p>
<ul>
<li><strong>进程内的内存回收</strong>:通过释放进程中的资源进行内存回收</li>
<li><strong>进程级的内存回收</strong>：通过杀死进程进行内存回收<br>进程内的内存回收分为两部分：</li>
<li><strong>虚拟机自身的垃圾回收机制</strong></li>
<li><strong>当系统内存发生改变的时候，通知应用程序，让开发者进行内存回收</strong><br>进程级的内存回收也分为两部分：</li>
<li><strong>Linux OOM Killer</strong><br>当系统已经没法再分配内存的时候，内核会遍历所有的进程，对每个进程计算badness值，得分(badness)最高的进程将会被杀死。</li>
<li><strong>LowMemoryKiller</strong><br>提供6个可以设置的内存级别，当系统内存每低于一个级别时，将oom_score_adj大于某个指定值的进程全部杀死。<br>在Java语言中，通过new创建的对象都会在堆中分配内存。应用程序堆的大小是有限的。系统会根据设备的物理内存大小来确定每个应用程序所允许使用的内存大小，一旦应用程序使用的内存超过这个大小，便会发生OutOfMemoryError。</li>
</ul>
<h1 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h1><ul>
<li>GCM</li>
<li>公共的第三方推送</li>
<li>和服务器轮询或者长连接<br>长连接的话需要检测是否长连接未失效</li>
</ul>
<h1 id="Dalvik-vs-ART"><a href="#Dalvik-vs-ART" class="headerlink" title="Dalvik vs ART"></a>Dalvik vs ART</h1><ul>
<li>Dalvik：APK在打包的时候Java文件会通过javac编译成.class，但是Dalvik只能执行.dex文件，所以Dalvik会先将class文件转化为dex文件。Dalvik虚拟机在启动的时候会先将.dex文件转换成快速运行的机器码，又因为65535这个问题，导致我们在应用冷启动的时候有一个合包的过程，最后导致的一个结果就是我们的app启动慢，这就是Dalvik虚拟机的JIT特性（Just In Time）。</li>
<li>ART： 该虚拟机Android5.0才出现，ART有一个很好的特性AOT（ahead of time），这个特性就是我们在安装APK的时候就将dex直接处理成可直接供ART虚拟机使用的机器码，ART虚拟机将.dex文件转换成可直接运行的.oat文件，ART虚拟机天生支持多dex，所以也不会有一个合包的过程，所以ART虚拟机会很大的提升APP冷启动速度。<br><strong>总结</strong></li>
</ul>
<p>ART优点：</p>
<ul>
<li>加快APP冷启动速度</li>
<li>提升GC速度</li>
<li><p>提供功能全面的Debug特性<br>ART缺点：</p>
</li>
<li><p>APP安装速度慢，因为在APK安装的时候要生成可运行.oat文件</p>
</li>
<li>APK占用空间大，因为在APK安装的时候要生成可运行.oat文件</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;p&gt; 为了确定保留或终止哪些进程，系统会根据进程中&lt;strong&gt;正在运行的组件&lt;/strong&gt;以及这些组件的状态，将每个进程放入“重要性层次
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 加载机制</title>
    <link href="http://yoursite.com/2017/12/21/Android%20%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/12/21/Android 加载机制/</id>
    <published>2017-12-20T16:00:00.000Z</published>
    <updated>2018-01-16T09:57:55.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-动态加载"><a href="#Android-动态加载" class="headerlink" title="Android 动态加载"></a>Android 动态加载</h1><h2 id="JVM加载机制"><a href="#JVM加载机制" class="headerlink" title="JVM加载机制"></a>JVM加载机制</h2><p>类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析、初始化，最终形成可以被虚拟机直接使用的Java类型<br>从类被加载到虚拟机内存中开始，到卸载出内存为止，类的生命周期包括加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。</p>
<ul>
<li><strong>加载</strong> </li>
</ul>
<ol>
<li><p>通过一个类的全限定名获取定义这个类的二进制流</p>
</li>
<li><p>将这个字节流代表的静态存储结构转化为方法区的运行时数据结构</p>
</li>
<li><p>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</p>
</li>
</ol>
<ul>
<li><strong>验证</strong></li>
</ul>
<p>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
<ul>
<li><strong>准备</strong></li>
</ul>
<p>虚拟机在准备阶段为类变量（static修饰的变量）分配内存，并设置类变量初始值。这些内存都将在方法区分配</p>
<p>有两个个方面需要特别强调：</p>
<ol>
<li><p>该阶段进行内存分配的仅包括类变量，不包括实例变量，实例变量将在对象初始化时随对象一起分配在堆内存中</p>
</li>
<li><p>这里所说的初始值“通常情况下”是指数据类型的零值，如一个类变量定义为：public static int a =1;，变量a在准备阶段之后的值为0而不是1</p>
</li>
</ol>
<p>程序编译后产生将a赋值为1的putstatic指令，并将该条指令存放在类构造器()中，故a赋值为1的动作将在初始化阶段完成</p>
<p>如果类字段的字段属性表中包含ConstantValue属性，那在准备阶段变量就会被初始化为ConstantValue属性所指定的值，即如果a变量定义变为public final static int a = 1;，编译时javac会为a生成ConstantValue属性，准备阶段虚拟机就会根据ConstantValue的设置将a的值置为1</p>
<ul>
<li><strong>解析</strong></li>
</ul>
<p>解析阶段是虚拟机将常量池中的符号引用（以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用目标并不一定已经加载到内存中）替换为直接引用（直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄，直接引用与虚拟机实现的内存布局相关，如果有了直接引用，引用目标必定已经加载到内存中）的过程</p>
<ul>
<li><strong>初始化</strong></li>
</ul>
<ol>
<li><p>遇到new（使用new关键字实例化对象）、getstatic（获取一个类的静态字段，final修饰符修饰静态字段除外）、putstatic（设置一个类的静态字段，final修饰符修饰的静态字段除外）和invokestatic（调用一个类的静态方法）这4条字节码指令时，如果类还没有初始化，则必须首先对其初始化</p>
</li>
<li><p>使用java.lang.reflect包中的方法对类进行反射调用时，如果类还没有初始化，则必须首先对其初始化</p>
</li>
<li><p>当初始化一个类时，如果其父类还没有初始化，则必须首先初始化其父类</p>
</li>
<li><p>当虚拟机启动时，需要指定一个主类（main方法所在的类），虚拟机会首选初始化这个主类</p>
</li>
</ol>
<h3 id="Java的加载方式通过JVM，Android使用classLoader进行加载，该类为抽象类，一般使用DexClassLoader和PathClassLoader进行加载"><a href="#Java的加载方式通过JVM，Android使用classLoader进行加载，该类为抽象类，一般使用DexClassLoader和PathClassLoader进行加载" class="headerlink" title="Java的加载方式通过JVM，Android使用classLoader进行加载，该类为抽象类，一般使用DexClassLoader和PathClassLoader进行加载"></a><strong>Java的加载方式通过JVM，Android使用classLoader进行加载，该类为抽象类，一般使用DexClassLoader和PathClassLoader进行加载</strong></h3><ul>
<li>DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk</li>
<li>PathClassLoader只能加载系统中已经安装过的apk</li>
</ul>
<p>热更新就是通过DexClassLoader来加载新的apk<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">loadApk</span><span class="params">(String apkPath)</span> </span>&#123;   </div><div class="line"> Log.v(<span class="string">"loadDexClasses"</span>, <span class="string">"Dex Preparing to loadDexClasses!"</span>);   </div><div class="line"> File dexOpt = <span class="keyword">this</span>.getDir(<span class="string">"dexOpt"</span>, MODE_PRIVATE);    </div><div class="line"> <span class="comment">//第一个参数被解压的apk路径，第二个解压后的.dex文件的存储路径，三os库的存放路径  ，四 父亲加载器，一般为context.getClassLoader()</span></div><div class="line"> <span class="keyword">final</span> DexClassLoader classloader = <span class="keyword">new</span> DexClassLoader(apkPath,dexOpt.getAbsolutePath(),      </div><div class="line">      <span class="keyword">null</span>,               </div><div class="line"> <span class="keyword">this</span>.getClassLoader());   </div><div class="line">   Log.v(<span class="string">"loadDexClasses"</span>, <span class="string">"Searching for class : "</span>                + <span class="string">"com.registry.Registry"</span>);       </div><div class="line"> <span class="keyword">try</span> &#123;        </div><div class="line">    Class&lt;?&gt; classToLoad = (Class&lt;?&gt;) classloader.loadClass(<span class="string">"com.dexclassdemo.liuguangli.apkbeloaded.ClassToBeLoad"</span>);          </div><div class="line">   Object instance = classToLoad.newInstance();         </div><div class="line">   Method method = classToLoad.getMethod(<span class="string">"method"</span>);    </div><div class="line">   method.invoke(instance);   </div><div class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; </div><div class="line">       e.printStackTrace();     </div><div class="line">   &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;   </div><div class="line">     e.printStackTrace();      </div><div class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;     </div><div class="line">     e.printStackTrace();      </div><div class="line">  &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;    </div><div class="line">    e.printStackTrace();     </div><div class="line">   &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;         </div><div class="line">    e.printStackTrace();       </div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如何加载另一个apk中的资源到当前应用中<br>加载资源一般使用Resourse，最终实际获取资源是通过一个AssetManager</p>
<ul>
<li>如何获取 AssetManager 对象:<br>AssetManager 的构造函数没有对 api 公开，不能使用 new 创建；context .getAssets() 可用获取当前上下文环境的 AssetManager；利用反射 AssetManager.class.newInstance() 这样可用获取对象。  </li>
<li>如何通过 AssetManager 对象获取插件中apk的资源<br>public native final int addAssetPath(String path);</li>
</ul>
<p>使用方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line">    ImageView imageView = (ImageView) findViewById(R.id.icon);</div><div class="line">    TextView textView = (TextView) findViewById(R.id.text);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  插件apk路径</div><div class="line">     */</div><div class="line">    String apkPath =Environment.getExternalStorageDirectory()+<span class="string">"/apkbeloaded-debug.apk"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  插件资源对象</div><div class="line">     */</div><div class="line">     <span class="function"><span class="keyword">public</span> Resources <span class="title">getBundleResource</span><span class="params">(Context context, String apkPath)</span></span>&#123;</div><div class="line">     AssetManager assetManager = createAssetManager(apkPath);</div><div class="line">     Resources resources =  <span class="keyword">new</span> Resources(assetManager,context.getResources().getDisplayMetrics(), context.getResources().getConfiguration());</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *获取图片资源</div><div class="line">     */</div><div class="line">    Drawable drawable = resources.getDrawable(resources.getIdentifier(<span class="string">"icon_be_load"</span>, <span class="string">"drawable"</span>,</div><div class="line">        <span class="string">"laodresource.demo.com.apkbeloaded"</span>));</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  获取文本资源</div><div class="line">     */</div><div class="line">    String text = resources.getString(resources.getIdentifier(<span class="string">"text_beload"</span>,<span class="string">"string"</span>,</div><div class="line">        <span class="string">"laodresource.demo.com.apkbeloaded"</span>));</div><div class="line"></div><div class="line">    imageView.setImageDrawable(drawable);</div><div class="line">    textView.setText(text);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> AssetManager <span class="title">createAssetManager</span><span class="params">(String apkPath)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        AssetManager assetManager = AssetManager.class.newInstance();</div><div class="line">        AssetManager.class.getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class).invoke(</div><div class="line">            assetManager, apkPath);</div><div class="line">        <span class="keyword">return</span> assetManager;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">        th.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>“注册”插件中的四大组件<br>在安装apk的时候，应用管理服务PackageManagerService会解析apk，解析应用程序配置文件AndroidManifest.xml，并从里面得到得到应用得到应用程序的组件Activity、Service、Broadcast Receiver和Content Provider等信息，对应用的每个组件“登记”，“登记”之后，在启动某个Activity过程在AMS执行时对比“登记”然后“查有此人”允许后续的启动行为  </p>
<ol>
<li>代理方式实现<br>宿主端实现一个 PluginProxyActivity，使用这个Activity代理插件中的Activity的重要事务，例如生命周期调用、contentview设置、Activity跳转等事务。PluginProxyActivity注册在宿主中，启动插件中的Activity实际就是启动PluginProxyActivity，只是加载的布局和方法逻辑不一样而已。百度的插件框架dynamic-load-apk就是使用的这种方式。</li>
<li>“占坑”方式实现<br>启动Activity是一个复杂的过程，有很多环节：Activity.startActivity()-&gt;Activity.startActivityForResult()-&gt;Instrument.excuteStartActivity()-&gt;AMS.startActivity()。大概又这么几个环节，详细了解可以参考文章：《深入理解Activity的启动过程》。 所谓“占坑”在宿主端的AndroidManifest.xml注册一个不存在的Activity，可以取名为StubActivity，同样启动插件的Activity都是启动StubActivity，然后在启动Activity的某个环节，我们找个“临时”演员来代替StubActivity，这个临时演员就是插件中定义的Activity，这叫“瞒天过海”</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-动态加载&quot;&gt;&lt;a href=&quot;#Android-动态加载&quot; class=&quot;headerlink&quot; title=&quot;Android 动态加载&quot;&gt;&lt;/a&gt;Android 动态加载&lt;/h1&gt;&lt;h2 id=&quot;JVM加载机制&quot;&gt;&lt;a href=&quot;#JVM加载机
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://yoursite.com/2017/12/18/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2017/12/18/二叉树/</id>
    <published>2017-12-17T16:00:00.000Z</published>
    <updated>2018-01-16T07:17:27.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>红黑树本质上是一颗二叉搜索树，它满足二叉搜索树的基本性质——即树中的任何节点的值大于它的左子节点，且小于它的右子节点。<br><img src="https://upload-images.jianshu.io/upload_images/5713484-169f0fef8703f997.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="二叉搜索树"></p>
<p>查找速度快，查找48这个数字，只需要查找四个节点。理论上，一颗平衡的二叉树搜索树的任意节点平均查找效率为树的高度n，即O(lgn)。但是如果二叉搜索树的失去平衡(元素在一侧)，搜索效率就退化为O(n)，因此二叉搜索树的平衡是搜索效率的关键所在。为了维护树的平衡性，数据结构内出现了各种各样的树，比如AVL树通过维持任何节点的左右子树的高度差 不大于1保持树的平衡，而红黑树使用颜色维持树的平衡，使二叉搜索树的左右子树的高度差 保持在固定的范围。相比于其他二叉搜索树，红黑树对二叉搜索树的平衡性维持着自身的优势</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>特性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1、节点是红色或黑色  </div><div class="line">2、根是黑色  </div><div class="line">3、所有叶子是黑色(叶子是NIL节点)  </div><div class="line">4、每个红色节点的两个子节点都是黑色的(从每个叶子到跟的所有路径不能有两个连续的红色节点)  </div><div class="line">5、从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二叉搜索树&quot;&gt;&lt;a href=&quot;#二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树&quot;&gt;&lt;/a&gt;二叉搜索树&lt;/h1&gt;&lt;p&gt;红黑树本质上是一颗二叉搜索树，它满足二叉搜索树的基本性质——即树中的任何节点的值大于它的左子节点，且小于它的右子节点
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Gradle</title>
    <link href="http://yoursite.com/2017/12/15/gradle/"/>
    <id>http://yoursite.com/2017/12/15/gradle/</id>
    <published>2017-12-14T16:00:00.000Z</published>
    <updated>2018-01-16T07:17:54.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gradle-使用"><a href="#gradle-使用" class="headerlink" title="gradle 使用"></a>gradle 使用</h1><ul>
<li>BuildConfig  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BuildConfigField &quot;String&quot; ,&quot;name&quot; ,&quot;value&quot;</div></pre></td></tr></table></figure>
<p> 配置这个参数意味着我们可以直接从BuildConfig.name中取出我们赋予的值<br> 该参数可以实现  </p>
<ol>
<li>分debug ,release版打印logcat    </li>
<li><p>针对不同打包版本赋值不同的baseUrl  </p>
<p>除此之外，我们还可以为不同的编译类型的设置不同的资源文件，比如：<br><img src="https://note.youdao.com/yws/api/personal/file/0443CEEAF78E4DDAA919513EAFB002AD?method=download&amp;shareKey=eda2c4582f40d512a3f638e311a9b8ec" alt="显示文本"></p>
</li>
</ol>
<p>该方法为两个版本的apk设置了不同的app名字</p>
<ul>
<li>Build Type<br>针对同一份源码编译同一个程序的不同类型  </li>
<li>Product flavors<br>针对同一份源码编译不同的程序（包名也不同）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;gradle-使用&quot;&gt;&lt;a href=&quot;#gradle-使用&quot; class=&quot;headerlink&quot; title=&quot;gradle 使用&quot;&gt;&lt;/a&gt;gradle 使用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;BuildConfig  &lt;/li&gt;
&lt;/ul&gt;
&lt;figure cla
    
    </summary>
    
      <category term="Gradle" scheme="http://yoursite.com/categories/Gradle/"/>
    
    
  </entry>
  
  <entry>
    <title>Animation 动画深度分析</title>
    <link href="http://yoursite.com/2016/02/21/%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2016/02/21/动画/</id>
    <published>2016-02-20T16:00:00.000Z</published>
    <updated>2017-06-20T08:16:48.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="View-Animation"><a href="#View-Animation" class="headerlink" title="View Animation"></a>View Animation</h2><p> 视图动画，也叫Tween（补间）动画可以在一个视图容器内执行一系列简单变换（位置、大小、旋转、透明度）。譬如，如果你有一个TextView对象，您可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。</p>
<ol>
<li>Alpha(透明度) 属性：用于控制动画的透明度</li>
<li>Rotate（旋转）属性 ：可以对视图进行旋转</li>
<li>Scale（缩放）属性：对视图进行缩放</li>
<li>Translate属性：可以对视图进行变换</li>
<li>AnimationSet继承自Animation，是上面四种的组合容器管理类，没有自己特有的属性，他的属性继承自Animation，当我们对set标签使用Animation的属性时会对该标签下的所有子控件都产生影响。</li>
<li>Interpolator（插值器）属性：类似于动画以一个什么样的速率去执行动画<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">	&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    </div><div class="line">	&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   </div><div class="line">    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;  </div><div class="line">    android:shareInterpolator=[&quot;true&quot; | &quot;false&quot;] &gt;</div><div class="line">    &lt;alpha</div><div class="line">        android:fromAlpha=&quot;float&quot;</div><div class="line">        android:toAlpha=&quot;float&quot; /&gt;</div><div class="line">    &lt;scale</div><div class="line">        android:fromXScale=&quot;float&quot;</div><div class="line">        android:toXScale=&quot;float&quot;</div><div class="line">        android:fromYScale=&quot;float&quot;</div><div class="line">        android:toYScale=&quot;float&quot;</div><div class="line">        android:pivotX=&quot;float&quot;</div><div class="line">        android:pivotY=&quot;float&quot; /&gt;</div><div class="line">    &lt;translate</div><div class="line">        android:fromXDelta=&quot;float&quot;</div><div class="line">        android:toXDelta=&quot;float&quot;</div><div class="line">        android:fromYDelta=&quot;float&quot;</div><div class="line">        android:toYDelta=&quot;float&quot; /&gt;</div><div class="line">    &lt;rotate</div><div class="line">        android:fromDegrees=&quot;float&quot;</div><div class="line">        android:toDegrees=&quot;float&quot;</div><div class="line">        android:pivotX=&quot;float&quot;</div><div class="line">        android:pivotY=&quot;float&quot; /&gt;</div><div class="line">    &lt;set&gt;</div><div class="line">        ...</div><div class="line">    &lt;/set&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<table>
<thead>
<tr>
<th>View类的常用动画操作方法</th>
<th>解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td>startAnimation(Animation animation)</td>
<td>对当前View开始设置的Animation动画</td>
</tr>
<tr>
<td>clearAnimation()</td>
<td>取消当View在执行的Animation动画</td>
</tr>
</tbody>
</table>
<p><strong>补间动画执行之后并未改变View的真实布局属性值。我们对一个Button进行操作，将他从原来的位置移动到另一位置，但是实际响应button事件的位置，还是原来的位置。</strong><br><a id="more"></a></p>
<h2 id="Drawable-Animation"><a href="#Drawable-Animation" class="headerlink" title="Drawable Animation"></a>Drawable Animation</h2><p> Drawable动画其实就是Frame动画（帧动画），它允许你实现像播放幻灯片一样的效果，这种动画的实质其实是Drawable，所以这种动画的XML定义方式文件一般放在res/drawable/目录下。加载效果的实现</p>
<ol>
<li><animation-list> 必须是根节点，包含一个或者多个item元素，包含属性如下：<ul>
<li>android:oneshot true代表只执行一次，false循环执行。</li>
</ul>
</animation-list></li>
<li>item 类似一帧的动画资源，animation-list的子项，包含属性如下：<ul>
<li>android:drawable 一个frame的Drawable资源。</li>
<li>android:duration 一个frame显示多长时间。</li>
</ul>
</li>
</ol>
<p><strong>AnimationDrawable的start()方法不能在Activity的onCreate方法中调运，因为AnimationDrawable还未完全附着到window上，所以最好的调运时机是onWindowFocusChanged()方法中。</strong></p>
<h2 id="Property-Animation"><a href="#Property-Animation" class="headerlink" title="Property Animation"></a>Property Animation</h2><p> 属性动画只对Android 3.0（API 11）以上版本的Android系统才有效，这种动画可以设置给任何Object，包括那些还没有渲染到屏幕上的对象。这种动画是可扩展的，可以让你自定义任何类型和属性的动画。<strong>实现原理就是修改控件的属性值实现的动画，改变的是对象的真实属性</strong><br>基本属性如下：</p>
<ul>
<li>Duration：动画的持续时间；</li>
<li>TimeInterpolation：定义动画变化速率的接口，所有插值器都必须实现此接口，如线性、非线性插值器；</li>
<li>TypeEvaluator：用于定义属性值计算方式的接口，有int、float、color类型，根据属性的起始、结束值和插值一起计算出当前时间的属性值；</li>
<li>Animation sets：动画集合，即可以同时对一个对象应用多个动画，这些动画可以同时播放也可以对不同动画设置不同的延迟；</li>
<li>Frame refreash delay：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响；</li>
<li>Repeat Country and behavoir：重复次数与方式，如播放3次、5次、无限循环，可以让此动画一直重复，或播放完时向反向播放；  </li>
</ul>
<h3 id="1-set属性解释："><a href="#1-set属性解释：" class="headerlink" title="1.set属性解释："></a>1.set属性解释：</h3><table>
<thead>
<tr>
<th>xml属性</th>
<th>解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td> android:ordering</td>
<td>控制子动画启动方式是先后有序的还是同时进行。sequentially:动画按照先后顺序；together(默认):动画同时启动 </td>
</tr>
</tbody>
</table>
<h3 id="2-objectAnimator属性解释："><a href="#2-objectAnimator属性解释：" class="headerlink" title="2.objectAnimator属性解释："></a>2.objectAnimator属性解释：</h3><table>
<thead>
<tr>
<th>xml属性</th>
<th>解释 </th>
</tr>
</thead>
<tbody>
<tr>
<td>android:propertyName</td>
<td>String类型，必须要设置的节点属性，代表要执行动画的属性（通过名字引用），辟如你可以指定了一个View的”alpha” 或者 “backgroundColor” ，这个objectAnimator元素没有对外说明target属性，所以你不能在XML中设置执行这个动画，必须通过调用 loadAnimator()方法加载你的XML动画资源，然后调用setTarget()应用到具备这个属性的目标对象上（譬如TextView）。</td>
</tr>
<tr>
<td>android:valueTo</td>
<td>float、int或者color类型，必须要设置的节点属性，表明动画结束的点；如果是颜色的话，由6位十六进制的数字表示。</td>
</tr>
<tr>
<td>android:valueFrom</td>
<td>相对应valueTo，动画的起始点，如果没有指定，系统会通过属性的get方法获取，颜色也是6位十六进制的数字表示。</td>
</tr>
<tr>
<td>android:duration</td>
<td>动画的时长，int类型，以毫秒为单位，默认为300毫秒。</td>
</tr>
<tr>
<td>android:startOffset</td>
<td>动画延迟的时间，从调用start方法后开始计算，int型，毫秒为单位。</td>
</tr>
<tr>
<td>android:repeatCount</td>
<td>一个动画的重复次数，int型，”-1“表示无限循环，”1“表示动画在第一次执行完成后重复执行一次，也就是两次，默认为0，不重复执行。</td>
</tr>
<tr>
<td>android:repeatMode</td>
<td>重复模式：int型，当一个动画执行完的时候应该如何处理。该值必须是正数或者是-1，“reverse”会使得按照动画向相反的方向执行，可实现类似钟摆效果。“repeat”会使得动画每次都从头开始循环。</td>
</tr>
<tr>
<td>android:valueType</td>
<td>关键参数，如果该value是一个颜色，那么就不需要指定，因为动画框架会自动的处理颜色值。有intType和floatType（默认）两种：分别说明动画值为int和float型。</td>
</tr>
</tbody>
</table>
<h3 id="3-XML属性动画使用方法："><a href="#3-XML属性动画使用方法：" class="headerlink" title="3.XML属性动画使用方法："></a>3.XML属性动画使用方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,</div><div class="line">   R.animtor.property_animator);</div><div class="line">set.setTarget(myObject);</div><div class="line">set.start();</div></pre></td></tr></table></figure>
<h3 id="4-ValueAnimator实现动画"><a href="#4-ValueAnimator实现动画" class="headerlink" title="4.ValueAnimator实现动画"></a>4.ValueAnimator实现动画</h3><p>属性动画中的时间驱动，管理着动画时间的开始、结束属性值，相应时间属性值计算方法等。包含所有计算动画值的核心函数以及每一个动画时间节点上的信息、一个动画是否重复、是否监听更新事件等，并且还可以设置自定义的计算类型。<br><strong>ValueAnimator只是动画计算管理驱动，设置了作用目标，但没有设置属性，需要通过updateListener里设置属性才会生效。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ValueAnimator animator = ValueAnimator.ofFloat(0, mContentHeight);  //定义动画</div><div class="line">animator.setTarget(view);   //设置作用目标</div><div class="line">animator.setDuration(5000).start();</div><div class="line">animator.addUpdateListener(new AnimatorUpdateListener() &#123;</div><div class="line">   @Override</div><div class="line">   public void onAnimationUpdate(ValueAnimator animation)&#123;</div><div class="line">       float value = (float) animation.getAnimatedValue();</div><div class="line">       view.setXXX(value);  //必须通过这里设置属性值才有效</div><div class="line">       view.mXXX = value;  //不需要setXXX属性方法</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="5-ObjectAnimator实现动画"><a href="#5-ObjectAnimator实现动画" class="headerlink" title="5.ObjectAnimator实现动画"></a>5.ObjectAnimator实现动画</h3><p>继承自ValueAnimator，允许你指定要进行动画的对象以及该对象 的一个属性。不需要和ValueAnimator那样自己写动画更新的逻辑，但是ObjectAnimator有一定的限制，比如它需要目标对象的属性提供指定 的处理方法（譬如提供getXXX，setXXX方法）<br>ObjectAnimator类提供了ofInt、ofFloat、ofObject这个三个常用的方法，这些方法都是设置动画作用的元素、属性、开始、结束等任意属性值。当属性值（上面方法的参数）只设置一个时就把通过getXXX反射获取的值作为起点，设置的值作为终点；如果设置两个（参数），那么一个是开始、另一个是结束。<br><strong>ObjectAnimator的动画原理是不停的调用setXXX方法更新属性值，所有使用ObjectAnimator更新属性时的前提是Object必须声明有getXXX和setXXX方法。</strong><br>我们通常使用ObjectAnimator设置View已知的属性来生成动画，而一般View已知属性变化时都会主动触发重绘图操作，所以动画会自 动实现；但是也有特殊情况，譬如作用Object不是View，或者作用的属性没有触发重绘，或者我们在重绘时需要做自己的操作，那都可以通过如下方法手 动设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator mObjectAnimator= ObjectAnimator.ofInt(view, &quot;customerDefineAnyThingName&quot;, 0,  1).setDuration(2000);</div><div class="line">mObjectAnimator.addUpdateListener(new AnimatorUpdateListener()</div><div class="line">       &#123;</div><div class="line">           @Override</div><div class="line">           public void onAnimationUpdate(ValueAnimator animation)</div><div class="line">           &#123;</div><div class="line">               //int value = animation.getAnimatedValue();  可以获取当前属性值</div><div class="line">               //view.postInvalidate();  可以主动刷新</div><div class="line">               //view.setXXX(value);</div><div class="line">               //view.setXXX(value);</div><div class="line">               //......可以批量修改属性</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>ValueAnimator和ObjectAnimator没啥区别，实际上正是由于ValueAnimator不直接操作属性值，所以要操作对象的属性可以不需要setXXX与getXXX方法，你完全可以通过当前动画的计算去修改任何属性。</p>
<h3 id="6-AnimatorSet的使用"><a href="#6-AnimatorSet的使用" class="headerlink" title="6.AnimatorSet的使用"></a>6.AnimatorSet的使用</h3><p>动画集合，提供把多个动画组合成一个组合的机制，并可设置动画的时序关系，如同时播放、顺序播放或延迟播放<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator a1 = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1.0f, 0f);  </div><div class="line">ObjectAnimator a2 = ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0f, viewWidth);  </div><div class="line">......</div><div class="line">AnimatorSet animSet = new AnimatorSet();  </div><div class="line">animSet.setDuration(5000);  </div><div class="line">animSet.setInterpolator(new LinearInterpolator());   </div><div class="line">//animSet.playTogether(a1, a2, ...); //两个动画同时执行  </div><div class="line">animSet.play(a1).after(a2); //先后执行</div><div class="line">......//其他组合方式</div><div class="line">animSet.start();</div></pre></td></tr></table></figure></p>
<h3 id="7-Evaluators"><a href="#7-Evaluators" class="headerlink" title="7.Evaluators"></a>7.Evaluators</h3><p> Evaluators就是属性动画系统如何去计算一个属性值。它们通过Animator提供的动画的起始和结束值去计算一个动画的属性值。</p>
<p>IntEvaluator：整数属性值。</p>
<p>FloatEvaluator：浮点数属性值。</p>
<p>ArgbEvaluator：十六进制color属性值。</p>
<p>TypeEvaluator：用户自定义属性值接口，譬如对象属性值类型不是int、float、color类型，你必须实现这个接口去定义自己的数据类型。</p>
<p>如下类型float[]：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = new ValueAnimator();</div><div class="line">valueAnimator.setDuration(5000);</div><div class="line">valueAnimator.setObjectValues(new float[2]); //设置属性值类型</div><div class="line">valueAnimator.setInterpolator(new LinearInterpolator());</div><div class="line">valueAnimator.setEvaluator(new TypeEvaluator&lt;float[]&gt;()</div><div class="line">&#123;</div><div class="line">   @Override</div><div class="line">   public float[] evaluate(float fraction, float[] startValue,</div><div class="line">                           float[] endValue)</div><div class="line">   &#123;</div><div class="line">       //实现自定义规则计算的float[]类型的属性值</div><div class="line">       float[] temp = new float[2];</div><div class="line">       temp[0] = fraction * 2;</div><div class="line">       temp[1] = (float)Math.random() * 10 * fraction;</div><div class="line">       return temp;</div><div class="line">   &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">valueAnimator.start();</div><div class="line">valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener()</div><div class="line">&#123;</div><div class="line">   @Override</div><div class="line">   public void onAnimationUpdate(ValueAnimator animation)</div><div class="line">   &#123;</div><div class="line">       float[] xyPos = (float[]) animation.getAnimatedValue();</div><div class="line">       view.setHeight(xyPos[0]);   //通过属性值设置View属性动画</div><div class="line">       view.setWidth(xyPos[1]);    //通过属性值设置View属性动画</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="8-Interpolators插值器"><a href="#8-Interpolators插值器" class="headerlink" title="8.Interpolators插值器"></a>8.Interpolators插值器</h3><ul>
<li><p>AccelerateDecelerateInterolator：先加速后减速。</p>
</li>
<li><p>AccelerateInterpolator：加速。</p>
</li>
<li><p>DecelerateInterpolator：减速。</p>
</li>
<li><p>AnticipateInterpolator：先向相反方向改变一段再加速播放。</p>
</li>
<li><p>AnticipateOvershootInterpolator：先向相反方向改变，再加速播放，会超出目标值然后缓慢移动至目标值，类似于弹簧回弹。</p>
</li>
<li><p>BounceInterpolator：快到目标值时值会跳跃。</p>
</li>
<li><p>CycleIinterpolator：动画循环一定次数，值的改变为一正弦函数：Math.sin(2 <em> mCycles </em> Math.PI * input)。</p>
</li>
<li><p>LinearInterpolator：线性均匀改变。</p>
</li>
<li><p>OvershottInterpolator：最后超出目标值然后缓慢改变到目标值。</p>
</li>
<li><p>TimeInterpolator：一个允许自定义Interpolator的接口，以上都实现了该接口。  </p>
<p> 自定义插值器：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//开始很慢然后不断加速的插值器  </div><div class="line">public class AccelerateInterpolator implements Interpolator &#123;</div><div class="line">   private final float mFactor;</div><div class="line">   private final double mDoubleFactor;</div><div class="line"></div><div class="line">   public AccelerateInterpolator() &#123;</div><div class="line">       mFactor = 1.0f;</div><div class="line">       mDoubleFactor = 2.0;</div><div class="line">   &#125;</div><div class="line">   //input  0到1.0。表示动画当前点的值，0表示开头，1表示结尾。</div><div class="line">   //return  插值。值可以大于1超出目标值，也可以小于0突破低值。</div><div class="line">   @Override</div><div class="line">   public float getInterpolation(float input) &#123;</div><div class="line">       //实现核心代码块</div><div class="line">       if (mFactor == 1.0f) &#123;</div><div class="line">           return input * input;</div><div class="line">       &#125; else &#123;</div><div class="line">           return (float)Math.pow(input, mDoubleFactor);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="9-LayoutAnimator容器布局动画"><a href="#9-LayoutAnimator容器布局动画" class="headerlink" title="9.LayoutAnimator容器布局动画"></a>9.LayoutAnimator容器布局动画</h3><p>对ViewGroup中View添加时的动画功能，我们可以用LayoutTransition对 ViewGroup中的View进行动画设置显示。LayoutTransition的动画效果都是设置给ViewGroup，然后当被<strong>设置动画的 ViewGroup中添加删除View时体现出来</strong>。该类用于当前布局容器中有View添加、删除、隐藏、显示等时候定义布局容器自身的动画和View的动 画，也就是说当在一个LinerLayout中隐藏一个View的时候，我们可以自定义 整个由于LinerLayout隐藏View而改变的动画，同时还可以自定义被隐藏的View自己消失时候的动画等。</p>
<p> LayoutTransition类中主要有五种容器转换动画类型，具体如下：</p>
<ul>
<li><p>LayoutTransition.APPEARING：当View出现或者添加的时候View出现的动画。</p>
</li>
<li><p>LayoutTransition.CHANGE_APPEARING：当添加View导致布局容器改变的时候整个布局容器的动画。</p>
</li>
<li><p>LayoutTransition.DISAPPEARING：当View消失或者隐藏的时候View消失的动画。</p>
</li>
<li><p>LayoutTransition.CHANGE_DISAPPEARING：当删除或者隐藏View导致布局容器改变的时候整个布局容器的动画。</p>
</li>
<li><p>LayoutTransition.CHANGE：当不是由于View出现或消失造成对其他View位置造成改变的时候整个布局容器的动画。</p>
</li>
</ul>
<p>XML方式使用系统提供的默认LayoutTransition动画：</p>
<p>我们可以通过如下方式使用系统提供的默认ViewGroup的LayoutTransition动画：</p>
<p>android:animateLayoutChanges=”true”</p>
<p>在ViewGroup添加如上xml属性默认是没有任何动画效果的，因为前面说了，该动画针对于ViewGroup内部东西发生改变时才有效，所以当我们设置如上属性然后调运ViewGroup的addView、removeView方法时就能看见系统默认的动画效果了。</p>
<p>还有一种就是通过如下方式设置：</p>
<p>android:layoutAnimation=”@anim/customer_anim”</p>
<p>在使用LayoutTransition时，你可以自定义这几种事件类型的动画，也可以使用默认的动画，总之最终都是通过 setLayoutTransition(LayoutTransition lt)方法把这些动画以一个LayoutTransition对象设置给一个ViewGroup。</p>
<p>譬如实现如上Xml方式的默认系统LayoutTransition动画如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mTransitioner = new LayoutTransition();</div><div class="line">mViewGroup.setLayoutTransition(mTransitioner);</div></pre></td></tr></table></figure></p>
<p>自定义这几类事件的动画，分别实现他们，可以像下面这么处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mTransitioner = new LayoutTransition();</div><div class="line">......</div><div class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, 0, 1);</div><div class="line">......//设置更多动画</div><div class="line">mTransition.setAnimator(LayoutTransition.APPEARING, anim);</div><div class="line">.....//设置更多类型的动画                </div><div class="line">mViewGroup.setLayoutTransition(mTransitioner);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;View-Animation&quot;&gt;&lt;a href=&quot;#View-Animation&quot; class=&quot;headerlink&quot; title=&quot;View Animation&quot;&gt;&lt;/a&gt;View Animation&lt;/h2&gt;&lt;p&gt; 视图动画，也叫Tween（补间）动画可以在一个视图容器内执行一系列简单变换（位置、大小、旋转、透明度）。譬如，如果你有一个TextView对象，您可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Alpha(透明度) 属性：用于控制动画的透明度&lt;/li&gt;
&lt;li&gt;Rotate（旋转）属性 ：可以对视图进行旋转&lt;/li&gt;
&lt;li&gt;Scale（缩放）属性：对视图进行缩放&lt;/li&gt;
&lt;li&gt;Translate属性：可以对视图进行变换&lt;/li&gt;
&lt;li&gt;AnimationSet继承自Animation，是上面四种的组合容器管理类，没有自己特有的属性，他的属性继承自Animation，当我们对set标签使用Animation的属性时会对该标签下的所有子控件都产生影响。&lt;/li&gt;
&lt;li&gt;Interpolator（插值器）属性：类似于动画以一个什么样的速率去执行动画&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;set xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    android:interpolator=&amp;quot;@[package:]anim/interpolator_resource&amp;quot;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    android:shareInterpolator=[&amp;quot;true&amp;quot; | &amp;quot;false&amp;quot;] &amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;alpha&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromAlpha=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toAlpha=&amp;quot;float&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;scale&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromXScale=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toXScale=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromYScale=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toYScale=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:pivotX=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:pivotY=&amp;quot;float&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;translate&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromXDelta=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toXDelta=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromYDelta=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toYDelta=&amp;quot;float&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;rotate&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:fromDegrees=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:toDegrees=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:pivotX=&amp;quot;float&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        android:pivotY=&amp;quot;float&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;set&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;/set&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/set&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;View类的常用动画操作方法&lt;/th&gt;
&lt;th&gt;解释 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;startAnimation(Animation animation)&lt;/td&gt;
&lt;td&gt;对当前View开始设置的Animation动画&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clearAnimation()&lt;/td&gt;
&lt;td&gt;取消当View在执行的Animation动画&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;补间动画执行之后并未改变View的真实布局属性值。我们对一个Button进行操作，将他从原来的位置移动到另一位置，但是实际响应button事件的位置，还是原来的位置。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
</feed>
